#include <netinet/in.h>
#include <net/ethernet.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <ifaddrs.h>

#include "glog/logging.h"


// This header only exists in Linux land
#if __linux__
#include <linux/if_packet.h>
#endif

#include "network_interfaces.h"


namespace com {
namespace seagate {
namespace kinetic {

bool NetworkInterfaces::GetNetworkInterfaces(std::vector<DeviceNetworkInterface>* interfaces, bool includeLoopback) {
    if (!interfaces) {
        return false;
    }
    interfaces->clear();

    DeviceNetworkInterface* network_interface;

    struct ifaddrs* ifaddr;
    if (getifaddrs(&ifaddr) == -1) {
        PLOG(ERROR) << "getifaddrs call failed";//NO_SPELL
        return false;
    }

    for (auto* ifaddr_iterator = ifaddr;
         ifaddr_iterator != NULL;
         ifaddr_iterator = ifaddr_iterator->ifa_next) {
        if (ifaddr_iterator->ifa_addr == NULL) {
            LOG(WARNING) << "Network interface has null ifa_addr";//NO_SPELL
            continue;
        }

        if (!includeLoopback) {
            if (strncmp("lo", ifaddr_iterator->ifa_name, 2) == 0) {
                // we don't care about loopback so move to next interface
                continue;
            }
        }

        // Because the linked list generated by getifaddrs() has a seperate interface
        // entry for each family type (AF_PACKET, AF_INET, etc.), the same interface will
        // be iterated over multiple times with different information each time. In order
        // to merge this information into a single entry per interface in our list, we need
        // to determine if the interface has been iterated over before and update its
        // information in our list if it has.
        for (std::vector<DeviceNetworkInterface>::iterator it = interfaces->begin(); true; ++it) {
            if (it == interfaces->end()) {
                // interface is not in list, create a new entry
                interfaces->emplace_back();
                network_interface = &(interfaces->back());
                network_interface->name = ifaddr_iterator->ifa_name;
                break;
            } else if (it->name == ifaddr_iterator->ifa_name) {
                // interface is in our list, use the existing entry
                network_interface = &(*it);
                break;
            }
        }

        int family = ifaddr_iterator->ifa_addr->sa_family;

        char ipv4[INET_ADDRSTRLEN] = {0};
        char ipv6[INET6_ADDRSTRLEN] = {0};

#ifdef AF_PACKET
        if (family == AF_PACKET) {
            struct sockaddr_ll *s = (struct sockaddr_ll*)ifaddr_iterator->ifa_addr;
            char mac_address[18] = {0};
            snprintf(mac_address,
                sizeof(mac_address),
                "%02x:%02x:%02x:%02x:%02x:%02x",
                s->sll_addr[0], s->sll_addr[1], s->sll_addr[2], s->sll_addr[3], s->sll_addr[4],
                    s->sll_addr[5]);
            network_interface->mac_address = mac_address;
        }
#endif
        if (family == AF_INET) {
            struct in_addr addr = ((struct sockaddr_in*)ifaddr_iterator->ifa_addr)->sin_addr;
            inet_ntop(family, &addr, ipv4, sizeof(ipv4));
            network_interface->ipv4 = ipv4;
        } else if (family == AF_INET6) {
            struct in6_addr addr = ((struct sockaddr_in6*)ifaddr_iterator->ifa_addr)->sin6_addr;
            inet_ntop(family, &addr, ipv6, sizeof(ipv6));
            network_interface->ipv6 = ipv6;
        }
    }

    freeifaddrs(ifaddr);

    RemoveInactiveInterfaces(interfaces);

    return true;
}

bool NetworkInterfaces::GetExternallyVisibleNetworkInterfaces(std::vector<DeviceNetworkInterface>* interfaces) {
    return GetNetworkInterfaces(interfaces, false);
}

bool NetworkInterfaces::GetAllNetworkInterfaces(std::vector<DeviceNetworkInterface>* interfaces) {
    return GetNetworkInterfaces(interfaces, true);
}

void NetworkInterfaces::RemoveInactiveInterfaces(std::vector<DeviceNetworkInterface>* interfaces) {
    if (!interfaces) {
        return;
    }

    std::vector<DeviceNetworkInterface>::iterator it = interfaces->begin();
    while (it != interfaces->end()) {
        if (it->ipv4.empty() && it->ipv6.empty()) {
            // interface has neither an ipv4 or ipv6 meaning no one can talk to it
            // so remove it from list (this handles bond slaves in particular)
            interfaces->erase(it);

            // erase() invalidates our iterator so we need to reinitialize it
            it = interfaces->begin();
        } else {
            ++it;
        }
    }

    // free up unused memory
    interfaces->shrink_to_fit();
}

} // namespace kinetic
} // namespace seagate
} // namespace com
