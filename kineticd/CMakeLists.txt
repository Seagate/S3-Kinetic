cmake_minimum_required(VERSION 2.8.6)
project(kinetic CXX C)

include(ExternalProject)

# Instructions for adding new source files:`
#
# New test source files should be added to the add_executable directive for
# kinetic_test below. Other .cc files should become part of the
# libkinetic library and should be added to the add_library directive below.
# Header files do not need to be listed here, with the exception of ones that
# are generated by the Protobuf compiler.

# All three of these variables must be manually updated when changing the proto version
set(KINETIC_PROTO_VERSION "4.0.1")
set(KINETIC_PROTO_GIT_HASH "f8d5d18")
set(KINETIC_PROTO_MD5 "0cacbbafec2686c6b7323ddb5a1599f9")

set(TEST_BINARY "kinetic_test")
SET(TEST_BINARY_PATH ${CMAKE_BINARY_DIR}/${TEST_BINARY})

OPTION(KEY_COUNT "Leveldb key count" OFF)
SET(PRODUCT "X86" CACHE STRING "Product build target")

MESSAGE ( ${PRODUCT} )

set(LEGACY_COMPILER_SETTINGS ON)

if(PRODUCT STREQUAL "LAMARRKV")
  message(STATUS "Building LamarrKV config")
  add_definitions(-DPRODUCT_LAMARRKV)
  set(BUILD_FOR_ARM ON)
  set(BUILD_FOR_ARM64 OFF)
  set(CMAKE_TOOLCHAIN_FILE ${CMAKE_SOURCE_DIR}/a382.cmake)
endif()

if(PRODUCT STREQUAL "LAMARRKV_LP")
  message(STATUS "Building ArmadaLP based Interposer config")
  add_definitions(-DPRODUCT_LAMARRKV_ARMADALP)
  set(BUILD_FOR_ARM ON)
  set(BUILD_FOR_ARM64 ON)
  set(LEGACY_COMPILER_SETTINGS OFF)
endif()

if(PRODUCT STREQUAL "X86NONSMR")
  message(STATUS "Building for X86NONSMR")
  SET(PLATFORM_PREPROCESSOR_DEFINE "-DPRODUCT_X86 -DNONSMR")
  add_definitions(-DPRODUCT_X86 -DNONSMR)
  set(BUILD_FOR_ARM OFF)
endif()

if(PRODUCT STREQUAL "X86SMR")
  message(STATUS "Building for X86SMR")
  SET(PLATFORM_PREPROCESSOR_DEFINE "-DPRODUCT_X86 -DSMR")
  add_definitions(-DPRODUCT_X86 -DSMR)
  set(BUILD_FOR_ARM OFF)
endif()

set(OS_SUFFIX "linux")
set(RT_LIBRARY "rt")

find_package (Threads)

if(NOT ${BUILD_FOR_ARM})
    set(ARCH_SUFFIX "x86")
    set(FILE_SUFFIX "x86")
    set(CMAKE_C_COMPILER "gcc")
    set(CMAKE_CXX_COMPILER "g++")
    set(NO_UNUSED_LOCAL_TYPEDEFS "-Wno-unused-local-typedefs")
    set(PLATFORM_PREPROCESSOR_DEFINE "${PLATFORM_PREPROCESSOR_DEFINE} -DBUILD_FOR_ARM=0")
    message("Build set for x86")
    message("${PLATFORM_PREPROCESSOR_DEFINE}")
else(NOT ${BUILD_FOR_ARM})
    set(FILE_SUFFIX "arm")
    if(${BUILD_FOR_ARM64})
        set(ARCH_SUFFIX "arm64")
        set(PLATFORM_PREPROCESSOR_DEFINE "-DBUILD_FOR_ARM=1 -DBUILD_FOR_ARM64=1")
        set(NO_UNUSED_LOCAL_TYPEDEFS "-Wno-unused-local-typedefs")
        message("Build set for 64 bit arm")
    else(NOT ${BUILD_FOR_ARM64})
        set(ARCH_SUFFIX "arm")
        set(PLATFORM_PREPROCESSOR_DEFINE "-DBUILD_FOR_ARM=1")
        set(NO_UNUSED_LOCAL_TYPEDEFS "-Wno-unused-local-typedefs")
        message("Build set for 32 bit arm")
    endif(${BUILD_FOR_ARM64})
    set(CMAKE_C_COMPILER $ENV{C_COMPILER})
    set(CMAKE_CXX_COMPILER $ENV{CXX_COMPILER})
    set(CMAKE_RANLIB $ENV{C_RANLIB})
    set(CHILD_MAKE_FLAGS CC=${CMAKE_C_COMPILER} CXX=${CMAKE_CXX_COMPILER} RANLIB=${CMAKE_RANLIB})
endif(NOT ${BUILD_FOR_ARM})

set(CMAKE_ARCH_LIB_PATH $ENV{C_ARCH_LIB_PATH})
set(CMAKE_ARCH_BIN_PATH $ENV{C_ARCH_BIN_PATH})

message("Using C Compiler: ${CMAKE_C_COMPILER}")
message("Using CXX Compiler: ${CMAKE_CXX_COMPILER}")
message("Using RANLIB: ${CMAKE_RANLIB}")
message("Input TOOLCHAIN FILE: ${CMAKE_TOOLCHAIN_FILE}")
message("Setting child make flags")

set(CHILD_FLAG_SETTINGS " --std=c++0x -DNDEBUG -Wall -Wextra -Werror -Wno-missing-field-initializers -Wno-sign-compare -Wno-unused-parameter -DGTEST_USE_OWN_TR1_TUPLE=1 -fPIC ${NO_UNUSED_LOCAL_TYPEDEFS}")
message("Testing child flags: ${CHILD_FLAG_SETTINGS}")
set(CMAKE_CXX_FLAGS "${CHILD_FLAG_SETTINGS} -D__STDC_FORMAT_MACROS -D_FILE_OFFSET_BITS=64 -DLEVELDB_PLATFORM_POSIX ${PLATFORM_PREPROCESSOR_DEFINE} -Wno-psabi -Wno-enum-compare -Wno-shift-count-overflow -Wno-unused-function -Wno-deprecated-declarations")
message("CMAKE_CXX_FLAGS: ${CMAKE_CXX_FLAGS}")

# This makes it easy to force XCode to always dump binaries in the working directory to be
# consistent with non-XCode builds
macro(store_build_products_in_working_dir TARGET_NAME)
    set_target_properties( ${TARGET_NAME} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY_DEBUG   ${CMAKE_BINARY_DIR}
        RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}
    )
endmacro(store_build_products_in_working_dir)

# Disable unused-parameter warning because it triggers warnings in the
# Protobuf-generated code

set(PREFIX "${CMAKE_BINARY_DIR}/vendor")

include(ExternalProject)

ExternalProject_add(
    kmem
    DOWNLOAD_COMMAND ""
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ""
    INSTALL_COMMAND ""
)

ExternalProject_Add_Step(
    kmem real_build
    COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR}/kmem && make clean all CXX=${CMAKE_CXX_COMPILER}
    COMMENT "== Building kmem Command Set =="
#    DEPENDEES build
    ALWAYS 1
)

ExternalProject_add(
    kinetic_cpp_client
    PREFIX "vendor"
    URL "${CMAKE_CURRENT_SOURCE_DIR}/kinetic_cpp_client"
    BUILD_IN_SOURCE 1
    CONFIGURE_COMMAND cmake -DBUILD_FOR_ARM=${BUILD_FOR_ARM} -DBUILD_FOR_ARM64=${BUILD_FOR_ARM64} -DPROTO_DIR=${CMAKE_BINARY_DIR}/vendor/src/kinetic-proto -DKERNEL_MEM_DIR=${CMAKE_CURRENT_SOURCE_DIR}/kmem -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TOOLCHAIN_FILE} -DPARENT_CXX_FLAGS=${CMAKE_CXX_FLAGS}
    INSTALL_COMMAND ""
)

ADD_DEPENDENCIES(kinetic_cpp_client kmem kinetic-proto)

ExternalProject_add(
    leveldb
    DOWNLOAD_COMMAND ""
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ""
    INSTALL_COMMAND ""
)

ExternalProject_Add_Step(
    leveldb real_build
    COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR}/smrdb && make clean libleveldb.a libsmrenv.a libmemenv.a CC=${CMAKE_C_COMPILER} CXX=${CMAKE_CXX_COMPILER} DIR=${CMAKE_CURRENT_SOURCE_DIR}/ha_zac_cmds/includes LIBS=${CMAKE_CURRENT_SOURCE_DIR}/ha_zac_cmds/zac_kin.a KMEM=${CMAKE_CURRENT_SOURCE_DIR}/kmem PP_DEFS=${PLATFORM_PREPROCESSOR_DEFINE}
    COMMENT "Building leveldb and smrdb"
    DEPENDEES build
    ALWAYS 1
)

ExternalProject_add(
    k_api
    DOWNLOAD_COMMAND ""
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ""
    INSTALL_COMMAND ""
)

if(${BUILD_FOR_ARM})
ExternalProject_Add_Step(
    k_api real_build
    COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR}/K_api && make kclean kinetic CC=${CMAKE_C_COMPILER} CXX=${CMAKE_CXX_COMPILER}
    COMMENT "Building K_api"
    DEPENDEES build
    ALWAYS 1
)
else(${BUILD_FOR_ARM})
ExternalProject_Add_Step(
    k_api real_build
    COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR}/K_api && make xkclean xkinetic CC=${CMAKE_C_COMPILER} CXX=${CMAKE_CXX_COMPILER}
    COMMENT "Building xK_api"
    DEPENDEES build
    ALWAYS 1
)
endif(${BUILD_FOR_ARM})

ExternalProject_add(
    ha_cmd
    DOWNLOAD_COMMAND ""
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ""
    INSTALL_COMMAND ""
)

ExternalProject_Add_Step(
    ha_cmd real_build
    COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR}/ha_zac_cmds && make clean all CXX=${CMAKE_CXX_COMPILER}
    COMMENT "== Building Host Aware Command Set =="
    DEPENDEES build
    ALWAYS 1
)

ExternalProject_add(
    lldp
    DOWNLOAD_COMMAND ""
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ""
    INSTALL_COMMAND ""
)

ExternalProject_Add_Step(
    lldp real_build
    COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR}/lldp && make clean all CXX=${CMAKE_CXX_COMPILER}
    COMMENT "== Building Link Layer Discovery Protocol =="
    DEPENDEES build
    ALWAYS 1
)

add_custom_target(leveldb_test
    COMMENT "Running leveldb tests"
    COMMAND cd ${CMAKE_CURRENT_SOURCE_DIR}/leveldb-1.16 && make check
    DEPENDS leveldb
)

set(OPENSSL_USE_STATIC_LIBS TRUE)
set(OPENSSL_ROOT_DIR ${CMAKE_ARCH_LIB_PATH})
find_package(OpenSSL REQUIRED)

include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/kmem
    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb/include
    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb
#    ${CMAKE_BINARY_DIR}/kinetic_cpp_client/include
    ${CMAKE_BINARY_DIR}/vendor/src/kinetic_cpp_client/include
    ${CMAKE_BINARY_DIR}/vendor/src/kinetic_cpp_client/src/main
    ${CMAKE_BINARY_DIR}/vendor/src/kinetic_cpp_client/src/main/generated
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/Kinetic_Security/api
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/Kinetic_Security/external_libs/PBKDFlib
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/api
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/transports
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/transports/SeaCPublic/include
#    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb/include
#    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb
    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb/smrdisk
    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb/util
    ${CMAKE_CURRENT_SOURCE_DIR}/ha_zac_cmds/includes
    ${CMAKE_CURRENT_SOURCE_DIR}/lldp/includes
    jsoncpp
)

include_directories(
    SYSTEM
    ${CMAKE_ARCH_LIB_PATH}/include
    ${OPENSSL_INCLUDE_DIR}
)

set(LIBRARY_DEPENDENCIES
#    ${CMAKE_BINARY_DIR}/kinetic_cpp_client/libkinetic_client.a
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/transports/libseapubcmds.a
    ${CMAKE_CURRENT_SOURCE_DIR}/kmem/kernel_mem_mgr.a
    ${OPENSSL_LIBRARIES}
    ${CMAKE_ARCH_LIB_PATH}/lib/libglog.a
    ${CMAKE_ARCH_LIB_PATH}/lib/libgtest.a
    ${CMAKE_ARCH_LIB_PATH}/lib/libgmock.a
    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb/libsmrenv.a
    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb/libleveldb.a
    ${CMAKE_CURRENT_SOURCE_DIR}/smrdb/libmemenv.a
    ${CMAKE_BINARY_DIR}/vendor/src/kinetic_cpp_client/libkinetic_client.a
    ${CMAKE_CURRENT_SOURCE_DIR}/ha_zac_cmds/zac_kin.a
    ${CMAKE_CURRENT_SOURCE_DIR}/lldp/lldp_kin.a
    ${CMAKE_ARCH_LIB_PATH}/lib/libprotobuf.a
    ${CMAKE_ARCH_LIB_PATH}/lib/libgflags.a
    ${CMAKE_THREAD_LIBS_INIT}
    dl
    ${RT_LIBRARY}
)

if(${BUILD_FOR_ARM})
set(SECURITY_DEPENDENCIES
    #Security API libraries
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/Kinetic_Security/api/libksapi.a
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/Kinetic_Security/external-libs/PBKDFlib/libpbkdf.a
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/api/libapi.a
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/transports/libtransports.a
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/transports/libseapubcmds.a
    ${CMAKE_CURRENT_SOURCE_DIR}/K_api/tcg_api/api/libapi.a
    #end Security API library list
)
endif(${BUILD_FOR_ARM})

add_library(kinetic
    jsoncpp/jsoncpp.cpp
    # We use a variable for indirection here so that the splice code is only
    # compiled on ARM builds.
    ${SPLICEABLE_VALUE}
    src/flag_vars.cc
    src/authorizer.cc
    src/connection_time_handler.cc
    src/connection_handler.cc
    src/connection_map.cc
    src/connection_queue.cc
    src/connection.cc
    src/device_information_${FILE_SUFFIX}.cc
    src/drive_info.cc
    src/domain.cc
    src/file_system_store.cc
    src/getlog_multicastor.cc
    src/hmac_authenticator.cc
    src/hmac_provider.cc
    src/internal_value_record.pb.cc
    src/key_value_store_interface.cc
    src/kinetic.pb.cc
    src/key_value_store.cc
    src/minio_skinny_waist.cc
    src/message_processor.cc
    src/openssl_initialization.cc
    src/outgoing_value.cc
    src/outgoing_value_${OS_SUFFIX}.cc
    src/port_listener.cc
    src/pretty_print_bytes.cc
    src/primary_store.cc
    src/profiler.cc
    src/pthreads_mutex_guard.cc
    src/server.cc
    src/signal_handling.cc
    src/skinny_waist.cc
    src/statistics_manager.cc
    src/std_map_key_value_store.cc
    src/user.cc
    src/user_store.cc
#    src/value_factory_${ARCH_SUFFIX}.cc
    src/value_factory_x86.cc
    src/log_ring_buffer.cc
    src/ring_buffer_log_sink.cc
    src/scheduled_background_task.cc
    src/cluster_version_store.cc
    src/p2p_operation_executor.cc
    src/p2p_push_callback.cc
    src/p2p_request_manager.cc
    src/p2p_request.cc
    src/db_logger.cc
    src/smartlog_processors.cc
    src/popen_wrapper.cc
    src/instant_secure_eraser_${FILE_SUFFIX}.cc
    src/network_interfaces.cc
    src/announcer_controller.cc
    src/multicast_announcer.cc
    src/lldp_announcer.cc
    src/getlog_handler.cc
    src/setup_handler.cc
    src/limits.cc
    src/user_serializer.cc
    src/cautious_file_handler.cc
    src/mount_manager.cc
    src/power_manager.cc
    src/pinop_handler.cc
    src/ise_state.cc
    src/store_inaccessible_state.cc
    src/store_corrupt_state.cc
    src/ready_state.cc
    src/locked_state.cc
    src/unlocked_state.cc
    src/restore_drive_state.cc
    src/start_server_state.cc
    src/manlocking_processor.cc
    src/security_manager.cc
    src/download_state.cc
    src/down_state.cc
    src/hibernate_state.cc
    src/shutdown_state.cc
    src/security_handler.cc
    src/schedule_compaction.cc
    src/launch_monitor.cc
    src/command_line_flags.cc
    src/pending_cmd_list_proxy.cc
    src/timer_mutex_guard.cc
    src/aging_timer.cc
    src/uboot_processor.cc
    src/kinetic_alarms.cc
    src/key_generator.cc
    src/net_processor.cc
    src/BatchCmd.cc
    src/BatchSet.cc
    src/BatchSetCollection.cc
    src/RequestQueue.cc
    src/PriorityRequestQueue.cc
    src/CommandValidator.cc
    src/common/event/EventService.cc
    src/kineticd.cc
    src/cmain.c
)

add_dependencies(kinetic
    kmem
    leveldb
    kinetic_cpp_client
    k_api
    ha_cmd
    lldp
    Version
)

add_custom_target(Version ALL
    COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/generate_version_info.sh ${KINETIC_PROTO_VERSION} ${KINETIC_PROTO_GIT_HASH})

#add_executable(kineticd src/cmain.c)
#store_build_products_in_working_dir(kineticd)

add_executable(manifest_stress src/manifest_stress.cc)
store_build_products_in_working_dir(manifest_stress)

add_executable(zac_ha_exercise_drive src/zac_ha_exercise_drive.cc)
store_build_products_in_working_dir(zac_ha_exercise_drive)

add_executable(bond_manager src/bond_manager.cc)
store_build_products_in_working_dir(bond_manager)

if(NOT ${BUILD_FOR_ARM})
add_executable(${TEST_BINARY}
    ${SPLICEABLE_VALUE_TEST}
    src/flag_vars.cc
    src/authorizer_test.cc
    src/connection_handler_test.cc
    src/device_information_test.cc
    src/domain_test.cc
    src/file_system_store_test.cc
    src/getlog_multicastor_test.cc
    src/hmac_provider_test.cc
    src/key_value_store_test.cc
    src/corrupt_key_value_store_test.cc
    src/kinetic_test.cc
    src/message_processor_test.cc
    src/nullable_outgoing_value_test.cc
    src/statistics_manager_test.cc
    src/outgoing_file_value_test.cc
    src/pretty_print_bytes_test.cc
    src/primary_store_test.cc
    src/skinny_waist_test.cc
    src/typed_test_helpers.cc
    src/user_store_test.cc
    src/log_ring_buffer_test.cc
    src/cluster_version_store_test.cc
    # src/p2p_operation_executor_test.cc
    src/p2p_request_test.cc
    src/p2p_request_manager_test.cc
    src/p2p_push_callback_test.cc
    src/key_value_store_test.cc
    src/network_interfaces_test.cc
    src/multicast_announcer_test.cc
    src/getlog_handler_test.cc
    src/setup_handler_test.cc
    src/security_handler_test.cc
    src/user_serializer_test.cc
    src/cautious_file_handler_test.cc
    src/threadsafe_blocking_queue_test.cc
    src/zac_kinetic_mediator_test.cc
    src/BatchCmd.cc
    src/BatchSet.cc
    src/BatchSetCollection.cc
    src/CommandValidator.cc
    src/common/event/EventService.cc
    src/smrdb_test_helpers.cc
    src/smrdb_db_test.cc
    src/smrdb_smrenv_test.cc
    src/smrdb_memenv_test.cc
    src/smrdb_arena_test.cc
    src/smrdb_bloom_test.cc
    src/smrdb_cache_test.cc
    src/smrdb_coding_test.cc
    src/smrdb_crc32_test.cc
    src/smrdb_dbformat_test.cc
    src/smrdb_skiplist_test.cc
    src/smrdb_env_test.cc
    src/smrdb_version_edit_test.cc
    src/smrdb_version_set_test.cc
    src/smrdb_write_batch_test.cc
)
store_build_products_in_working_dir(${TEST_BINARY})
target_link_libraries(${TEST_BINARY} kinetic ${LIBRARY_DEPENDENCIES})
endif(NOT ${BUILD_FOR_ARM})

#target_link_libraries(kineticd kinetic ${LIBRARY_DEPENDENCIES})
target_link_libraries(manifest_stress kinetic ${LIBRARY_DEPENDENCIES} ${LIBRARY_DEPENDENCIES})
target_link_libraries(zac_ha_exercise_drive kinetic ${LIBRARY_DEPENDENCIES})
target_link_libraries(bond_manager kinetic ${LIBRARY_DEPENDENCIES})

if(${BUILD_FOR_ARM})
#target_link_libraries(kineticd kinetic ${SECURITY_DEPENDENCIES})
target_link_libraries(manifest_stress kinetic ${SECURITY_DEPENDENCIES})
target_link_libraries(zac_ha_exercise_drive kinetic ${LIBRARY_DEPENDENCIES})
target_link_libraries(bond_manager kinetic ${LIBRARY_DEPENDENCIES})
endif(${BUILD_FOR_ARM})

ExternalProject_add(
    kinetic-proto
    PREFIX ${PREFIX}
    DOWNLOAD_COMMAND curl -L https://github.com/Seagate/kinetic-protocol/archive/${KINETIC_PROTO_VERSION}.tar.gz -o kinetic-proto.tar.gz && openssl md5 kinetic-proto.tar.gz | grep -q ${KINETIC_PROTO_MD5} && rm -rf kinetic-proto && mkdir -p kinetic-proto && tar -xz --strip-components 1 -C kinetic-proto -f kinetic-proto.tar.gz
    BUILD_IN_SOURCE 1
    CONFIGURE_COMMAND ""
    BUILD_COMMAND ""
    INSTALL_COMMAND ""
)

# Protobuf code generation rules
set(PROTOC_PATH "${CMAKE_ARCH_BIN_PATH}/bin/protoc")
set(PROTO_DIR "${CMAKE_BINARY_DIR}/vendor/src/kinetic-proto")
set(PROTO_PATH "${PROTO_DIR}/kinetic.proto")
add_custom_command(
    OUTPUT ${kinetic_SOURCE_DIR}/src/kinetic.pb.h ${kinetic_SOURCE_DIR}/src/kinetic.pb.cc
    COMMAND ${PROTOC_PATH} -I=${PROTO_DIR} --cpp_out=${kinetic_SOURCE_DIR}/src ${PROTO_PATH}
    DEPENDS kinetic_cpp_client kinetic-proto
)

add_custom_command(
    OUTPUT ${kinetic_SOURCE_DIR}/src/internal_value_record.pb.h ${kinetic_SOURCE_DIR}/src/internal_value_record.pb.cc
    COMMAND ${PROTOC_PATH} -I=${kinetic_SOURCE_DIR}/src;${kinetic_SOURCE_DIR}/src/common/event --cpp_out=${kinetic_SOURCE_DIR}/src ${kinetic_SOURCE_DIR}/src/internal_value_record.proto
    DEPENDS kinetic_cpp_client ${kinetic_SOURCE_DIR}/src/internal_value_record.proto
)

# Rule for running tests
add_custom_target(check
    COMMAND ${TEST_BINARY_PATH} --gtest_output=xml:gtestresults.xml
    DEPENDS ${TEST_BINARY_PATH}
)

# Rule for running valgrind
IF(APPLE)
add_custom_target(test_valgrind
    COMMAND echo "Valgrind not supported on OSX"
)
add_custom_target(test_valgrind_report
    COMMAND echo "Valgrind not supported on OSX"
)
ELSE()
add_custom_target(test_valgrind
    COMMAND valgrind --gen-suppressions=all --max-stackframe=10000000 --leak-check=full --show-reachable=yes --track-fds=yes --suppressions=${CMAKE_SOURCE_DIR}/valgrind_linux.supp --child-silent-after-fork=yes ${TEST_BINARY_PATH}
    DEPENDS ${TEST_BINARY_PATH}
)

# Rule for running valgrind with reports
add_custom_target(test_valgrind_report
    COMMAND valgrind --gen-suppressions=all --max-stackframe=10000000 --leak-check=full --show-reachable=yes --track-fds=yes --suppressions=${CMAKE_SOURCE_DIR}/valgrind_linux.supp --child-silent-after-fork=yes --xml=yes --xml-file=valgrind_report.xml ${TEST_BINARY_PATH} --gtest_output=xml:gtestresults.xml
    DEPENDS ${TEST_BINARY_PATH}
)
ENDIF(APPLE)
