/***********************************************************************************
*
* Header: ks_initialize.c
* Date: 2014/02/28
* Author: Chris N Allo
*
* Description: Setup SED bands and take ownership of key SED credentials.
*
* CHANGELIST:
*	7/2/14   changed Debug output handling for EAPI type calls to KS_EAPIABORT
*                instead of KS_ABORT  CA
*                did some rearranging of the comments in the front of the module CA
*------------------------------------------------------------------------------------
* Do NOT modify or remove this copyright and confidentiality notice.
 *
 * Copyright 2014 Seagate Technology LLC.
 *
 * The code contained herein is CONFIDENTIAL to Seagate Technology LLC
 * and may be covered under one or more Non-Disclosure Agreements. All or
 * portions are also trade secret. Any use, modification, duplication,
 * derivation, distribution or disclosure of this code, for any reason,
 * not expressly authorized is prohibited. All other rights are expressly
 * reserved by Seagate Technology LLC.
 *
*/

/**
 * @file ks_initialize.c
 *
 * Setup SED bands and take ownership of key SED credentials.
 *
 * Bands are to be allocated starting at *band_start_LBA* and sized
 * according to the values in *band_sizes*. Bands are allocated
 * back to back with no gaps between.
 *
 * Implementation Notes:
 * * PIN values shall be generated by invoking TCG Random method.
 * * PIN values shall be stored on the drive in the TCG DataStore table.
 * * Due to lack of Kinetic Admin PIN, the pins here will be stored in the clear.
 * * ks_setup must be executed before this routine to set all global variables
 *
 * @param[in] band_sizes the size of each band to be allocated.
 * @param[in] BandSizesCount number of valid *bandsizes* values.
 * @param[in] band_start_LBA the LBA of the first band in band_sizes.
 * @return SUCCESS if all goes well, otherwise the first error encountered.
 *
 * Check locking status. If locked, fail.
 * Start Transaction
 * Generate, set and store Erasemaster PIN value
 * Setup band(s)
 * Generate and set Bandmaster PIN value for each Band
 * Store PIN values in DataStore table
 * Commit Transaction
 *
 * Start Transaction
 * Change SID value
 * Commit Transaction
 */

/* standard c includes */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* From EAPI functions */
#include "low_level.h"
#include "high_level.h"
#include "transport.h"
#include "parameters.h"
#include "utilities.h"

/* Local functions */
#include "ks_globals.h"
#include "ks_setup.h"
#include "ks_utilities.h"
#include "ks_setpin.h"
#include "ks_initialize.h"
#include "ks_debug.h"

/* From PBKDF functions */
#include "types.h"
#include "sc_pbkdf.h"
#include "aes_gcm.h"
#include "sc_aes.h"
#include "sc_aescrypt.h"
#include "sc_hmac.h"
#include "sc_sha2.h"

discovered_data discovery_data;  /* this needs to sit in a global area move to ks_globals.h */
SED_datastore_struct DataStoreData;

/* THESE WERE TAKEN OUT OF high_level.c */
/** This is the value to be used in a lot of calls if a pin is not provided.
 *  It will be set during discovery and should not be changed by client code.
 */
tcgByteValue msidPin; 

/** The parameters for the last Set method call that was done by a high_level
 *  function.
 */
static parameters lastToSet;


ks_status ks_initialize(band_size_t *band_sizes, uint8_t BandSizesCount, band_start_t band_start_LBA) {
   
   tcgByteValue		MasterKey;
   tcgByteValue	 	Generated_Pin,BandMaster0Pin;
   tcgByteValue		tcgDataStore;
//   tcgByteValue		Temp_val;
   parameters 		*toSet;
   band_start_t 	StartLBA;
   band_number_t 	BandNumber;

   char                 WhichBandMaster[MAX_SUPPORTABLE_BANDS];
   tcgByteValue		DataStoreString;
   uint16_t 		Tag_Length;  
   uint32_t 		Pin_Length;
   int			GCM_Error;
   band_size_t		Band_Length;
   const uint8          PBKDF_NULL[] = "";
   char			info_str[200];
#ifdef Decrypt_TEST_ON
   tcgByteValue		Retrieved_Pin;
#endif
    


   if (BandSizesCount > MAX_SUPPORTED_BANDS) {  /* MAX_SUPPORTED BANDS is the number of bands we can handle in ths code version */
     /* we error out here since the user is expecting to setup more bands than we support */
     KS_DEBUG(KS_PARAMETER_ERROR, KS_APIRETURN, "KS_INITIALIZE:ERROR band sizes count entered exceeds Max Supported Bands");
   }

   /* We assume ks_setup command was called before this routine that will have done initial questioning
   *  of the drive.  If it hasnt been called the Device_Identifier string will be all zeros and we should quit.
   * ks_setup also checks to see if the drive is in the factory default state.
   */
 
   /* Device Identifier is set by ks_security, if that hasnt been called it will be NULL */   
   if (Device_Identifier[0] == 0) {
     /* we cant continue since ks_setup has not been run. it loads discovery data structure */
     KS_DEBUG(KS_SYSTEM_SETUP_FAILURE, KS_APIRETURN,"KS_INITIALIZE:General Failure: Device Identifier not set:  Need to call KS_SETUP ");
   }

   if (Debug_Info == 2) {
     /* if debug set to 2 we leave after discovery */
     /* print discovery data here before we leave */
     printDiscoveryData(&discovery_data);
     KS_DEBUG(0,KS_INFO,"KS_INITIALIZE:Debug Level 2 [Discovery] completion");
     return KS_DEBUG_EXIT;
   }


   /* Initialize DataStoreData area to all 0's */
   memset(&DataStoreString.data, 0, MAX_DATASTORE_SIZE);
   KS_DEBUG(Load_DataStoreStructure(&DataStoreData,&DataStoreString), KS_ABORT, "Cleared Data Store Structure ");

   /******************* Set EraseMaster PIN first *******************************************/
   
 
   /* open a new session under LOCKING SP and start a new transaction */
   KS_DEBUG(issueStartSession("LockingSP"), KS_RETURN, "EM Start Session LockingSP"); 

   KS_DEBUG(issueStartTransaction(), KS_EAPIABORT, "EM Start Transaction");

   /* Since this is a new drive lets get a fresh random IV value to be used for the life of this drive */
   Generated_Pin.len = IV_SIZE; 
   KS_DEBUG(issueRandom((int)Generated_Pin.len, (char *)Generated_Pin.data), KS_EAPIABORT, "EM Issue Random NEW IV Return");
   memcpy(DataStoreData.IV,Generated_Pin.data,IV_SIZE);

   /* Put Header Info in Data store structure so it will be stored */
   memcpy(DataStoreData.Header, CURRENT_VERSION, HEADER_SIZE);
/*
   if (Debug_Info >= DEBUG_CRYPTO) {
      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.Header, (unsigned int) HEADER_SIZE); 
      printf("   HEADER         = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );
   }
*/

   /* get random pin */
   Generated_Pin.len = PIN_SIZE; /* Our pins are always 32 that we generate */
   KS_DEBUG(issueRandom((int)Generated_Pin.len, (char *)Generated_Pin.data), KS_EAPIABORT, "Issue Random EraseMaster Return");  

   toSet = &lastToSet;  
   resetParameters(toSet);  /* get clean parameter list */
 
   /* old pin is MSID */
   KS_DEBUG(issueAuthenticate("EraseMaster", &msidPin ), KS_EAPIABORT, "Authenticate EraseMaster Return");  

   /* Empty cell_block - cell_block does not apply to Set on Objects */
   setStartList(toSet);
   setEndList(toSet);

   /* Values - list of list of Column-name/value named-pairs */
   setStartList(toSet);
   setStartList(toSet);
   KS_DEBUG(setNamedByteValue(toSet, tcgTmpName("PIN"), &Generated_Pin), KS_EAPIABORT, "Set NamedByte EraseMaster Return");
   setEndList(toSet);
   setEndList(toSet);
  
   /* make command and payload from toset and send */
   KS_DEBUG(issueSet(pinNameToUID("EraseMaster"), toSet), KS_EAPIABORT, "Issue Set EraseMaster Return"); 

 
   /***************  Encrypt EraseMaster Pin Start  *********************/

     /* Encrypt EraseMaster pin with NULL password and store encrypted pin, SALT and TAG in data store structure */

     /* generate a new SALT */
     KS_DEBUG(issueRandom((int)SALT_SIZE,(char *)DataStoreData.SaltEM), KS_EAPIABORT,"Created new SALT for EraseMaster");

     MasterKey.len = PIN_SIZE;

     KS_DEBUG((PBKDF( (uint8 *)PBKDF_NULL, 
                      (uint32 )0,
                      (uint8*)DataStoreData.SaltEM,
                      (uint32 )SALT_SIZE,
                      (uint32 )ITERATION_COUNT, 
                      (uint16 )MasterKey.len, 
                      (uint8 *)MasterKey.data )-1), KS_ABORT, "Generated NEW Master Key EM");

    KS_DEBUG(0, KS_INFO, "KS_INITIALIZE:EraseMaster [Master Key] completion");

    /* Now GCM_Encrypt with new_pin (master key, IV, unencyrpted_pin) --> TAG, encrypted_pin */
    GCM_Error  = EncryptGCM_Mode( (uint8 *)Generated_Pin.data, PIN_SIZE, 
                                  (uint8 *)PBKDF_NULL, 0, \
                                  (uint8 *)DataStoreData.IV, IV_SIZE,\
                                  (uint8 *)MasterKey.data, MasterKey.len, \
                                  (uint8 *)DataStoreData.EraseMasterPin, &Pin_Length, \
                                  (uint8 *)DataStoreData.TagEM, &Tag_Length );

     if ((GCM_Error > 0 ) || (Pin_Length != PIN_SIZE) || (Tag_Length != TAG_SIZE)) {
       KS_DEBUG(GCM_Error, KS_GCMABORT, "ENCRYPTGCM failure EraseMaster");
     }

     /* data store structure should have EraseMasterPin, SaltEM, TagEM and IV loaded */
/*
    if (Debug_Info >= DEBUG_CRYPTO){
      printf("KS_INITIALIZE:Debug [Set Erasemaster PIN] completion\n ");
     
      printf("  EraseMaster PIN = %s\n ",tcgByteValueDebugAllHexStr(&Generated_Pin) );

      printf("  Master Key       = %s\n ",tcgByteValueDebugAllHexStr(&MasterKey));

      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.EraseMasterPin, (unsigned int) Pin_Length);
      printf("  EM Encrypted PIN = %s\n ",tcgByteValueDebugAllHexStr(&Temp_val));

      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.TagEM, TAG_SIZE);    
      printf("  TAG Value        = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );

      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.SaltEM, SALT_SIZE); 
      printf("  SALT Value       = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );

      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.IV, IV_SIZE); 
      printf("  IV Value         = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );
    }

#ifdef Decrypt_TEST_ON
       GCM_Error = DecryptGCM_Mode_Wrapper((uint8 *)DataStoreData.EraseMasterPin,PIN_SIZE,(uint8 *)NULL,0,\
                                           (uint8 *)DataStoreData.TagEM, TAG_SIZE,\
                                           (uint8 *)DataStoreData.IV, IV_SIZE, (uint8 *)MasterKey.data, MasterKey.len,\
                                           (uint8 *)Retrieved_Pin.data, &Retrieved_Pin.len );
    if (Debug_Info > DEBUG_OFF){
      printf("Retrieved:  Pin Length = %d  Tag_length = %d \n", Pin_Length, Tag_Length);
      printf("KS_INITIALIZE:Debug [Decrypt Erasemaster PIN] completion\n ");
      printf("  EM Retrieved PIN = %s\n ",tcgByteValueDebugAllHexStr(&Retrieved_Pin) );
      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.EraseMasterPin, (unsigned int) Pin_Length); 
      printf("  EM Encrypted PIN = %s\n ",tcgByteValueDebugAllHexStr(&Temp_val)); 
      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.TagEM, (unsigned int) Tag_Length);   
      printf("  TAG Value        = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );
    }
#endif
*/

     /* remove masterkey, generated pin data */
     memset(MasterKey.data, 0, MasterKey.len);
     MasterKey.len = PIN_SIZE;
     memset(Generated_Pin.data, 0, Generated_Pin.len);
     Generated_Pin.len = 0;

   /**************  Encrypt EraseMaster Pin Completed  ********************/

   /* do we want to keep the change and leave or abort the change and leave */
   if (Debug_Info == 3) {  /* 3 = keep change  */
     /* if debug set to 3 we leave after Erasemaster Pin is set up */
     KS_DEBUG(0, KS_INFO, "KS_INITIALIZE:Debug Level 3 [Set Erasemaster PIN] completion Close Session");
     /* end transaction and close session */
     KS_DEBUG(issueCommitTransaction(), KS_INFO, "DEBUG EXIT 3 Commit"); 
     KS_DEBUG(issueCloseSession(), KS_INFO, "DEBUG EXIT 3 Close");
     return KS_DEBUG_EXIT;
   }
   if (Debug_Info == 4) {  /* 4 = abort change  */
     /* if debug set to 4 we leave after Erasemaster Pin is set up */
     KS_DEBUG(1, KS_ABORT, "KS_INITIALIZE:Debug Level 4 [Set Erasemaster PIN ABORT] ");  /**** FIX  ***/
   }

   /******************* Set EraseMaster PIN Completed *******************************************/


   /******************* Set BandMaster PINs 0 - 8 and bands****************************************/
   /* We will set up Pins for bands 0 -8 and also set band sizes for those specified up to the ****/
   /* MAX_SUPPORTED_BANDS.  */

   /* Initialize StartLBA value.  handle case where no bands are being set up */
   if (BandSizesCount != 0)
     StartLBA = band_start_LBA; /* passed in value */
   else
     StartLBA = 0;

   /* set pin on 0-8 bands and set band start and length to values given or 0,0 as a default */
   /* generate an encrypted version of each pin that will get stored in the data store table as we go */
   
   /* NOTE: Autentication is assumed is already done to the EraseMaster previous to this step */

   for (BandNumber = 0; BandNumber < MAX_SUPPORTABLE_BANDS; BandNumber++) {  /* lets set up pins for all bands supportable */
   
      Generated_Pin.len = PIN_SIZE;         /* Our pins are always 32 that we generate */
      KS_DEBUG(issueRandom((int)Generated_Pin.len, (char *)Generated_Pin.data), KS_EAPIABORT, "Issue Random BandMaster[x] Return");
  
      sprintf(WhichBandMaster, "BandMaster%d", BandNumber);
   
      sprintf(info_str,"Processing %s",WhichBandMaster);
      KS_DEBUG(0,KS_INFO,info_str);


      toSet = &lastToSet;  
      resetParameters(toSet);

      /* set authority on BandMasterX */
        /* Empty cell_block - cell_block does not apply to Set on Objects */
        setStartList(toSet);
        setEndList(toSet);
        /* Values - list of list of Column-name/value named-pairs */
        setStartList(toSet);
        setStartList(toSet);
        KS_DEBUG(setNamedIntValue(toSet, tcgTmpName("Enabled"), 1), KS_EAPIABORT, "SetNamed IntValue Enable BandMaster[x] Return");
        setEndList(toSet);
        setEndList(toSet);
        KS_DEBUG(issueSet(authorityNameToUID(WhichBandMaster), toSet), KS_EAPIABORT, "Set Authority BandMaster[x] Return");
      /* Set Authority Complete */

      /* use MSIDPIN for each pin since this is a fresh install */
        KS_DEBUG(issueAuthenticate(WhichBandMaster, &msidPin ), KS_EAPIABORT, "Authenticate BandMaster[x] Return"); 

      /* Now set Pin */
        toSet = &lastToSet;  
        resetParameters(toSet);

        /* Empty cell_block - cell_block does not apply to Set on Objects */
        setStartList(toSet);
        setEndList(toSet);

        /* Values - list of list of Column-name/value named-pairs */
        setStartList(toSet);
        setStartList(toSet);
        KS_DEBUG(setNamedByteValue(toSet, tcgTmpName("PIN"), &Generated_Pin), KS_EAPIABORT, "SetNamed Byte PIN BandMaster[x] Return");
        setEndList(toSet);
        setEndList(toSet);
        KS_DEBUG(issueSet(pinNameToUID(WhichBandMaster), toSet), KS_EAPIABORT, "Issue Set PIN BandMaster[x] Return"); 

     /***************  Encrypt BandMasterPin[X] Start  *********************/

     /* Encrypt BandMasterPin[X] with NULL password and store encrypted pin, SALT and TAG in data store structure */

       /* generate a new SALT */
       KS_DEBUG(issueRandom((int)SALT_SIZE,(char *)DataStoreData.SaltBM[BandNumber]), KS_EAPIABORT,"Created new SALT for BandMaster[X]");

       /* generate a master Key (SALT, IV, new_pin) */
       KS_DEBUG((PBKDF( (uint8 *)PBKDF_NULL, 
                        (uint32 )0,
                        (uint8* )DataStoreData.SaltBM[BandNumber],
                        (uint32 )SALT_SIZE,
                        (uint32 )ITERATION_COUNT, 
                        (uint16 )MasterKey.len, 
                        (uint8 *)MasterKey.data )-1), KS_ABORT, "Generated NEW Master Key BandMaster[X]"); 
  
       /* Now GCM_Encrypt with new_pin (master key, IV, unencyrpted_pin) --> TAG, encrypted_pin */
       GCM_Error  = EncryptGCM_Mode( (uint8 *)Generated_Pin.data, PIN_SIZE,
                                     (uint8 *) PBKDF_NULL, 0, 
                                     (uint8 *)DataStoreData.IV, IV_SIZE,
                                     (uint8 *)MasterKey.data, MasterKey.len, 
                                     (uint8 *)DataStoreData.BandMasterPin[BandNumber], &Pin_Length, 
                                     (uint8 *)DataStoreData.TagBM[BandNumber], &Tag_Length );

       if ((GCM_Error > 0 ) || (Pin_Length != PIN_SIZE) || (Tag_Length != TAG_SIZE)) {
         KS_DEBUG(GCM_Error, KS_GCMABORT, "ENCRYPTGCM failure BandMaster[X]");
       }
/*
    if (Debug_Info >= DEBUG_CRYPTO){
      printf("KS_INIT:Debug \n ");

      printf("  Master Key       = %s\n ",tcgByteValueDebugAllHexStr(&MasterKey));
      printf("  Raw BM PIN      = %s\n ",tcgByteValueDebugAllHexStr(&Generated_Pin) );
      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.BandMasterPin[BandNumber], (unsigned int) Pin_Length);
      printf("  BM[%d] Encrypted PIN = %s\n ",BandNumber,tcgByteValueDebugAllHexStr(&Temp_val));

      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.TagBM[BandNumber], TAG_SIZE);    
      printf("  TAG Value        = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );
      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.TagBM[0], TAG_SIZE);    
      printf("  BM0TAG Value        = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );

      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.SaltBM[BandNumber], SALT_SIZE); 
      printf("  SALT Value       = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );

      tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.IV, IV_SIZE); 
      printf("  IV Value         = %s \n",tcgByteValueDebugAllHexStr(&Temp_val) );
    }
*/
       /* data store structure should have BandMasterPin, SaltBM, TagBM and IV loaded for BandMaster[X] */

       if (BandNumber == 0) {
         /* Keep Bandmaster0 Pin in unecrypted format so we can use later on to store Data store again after we update SID Pin */
         tcgByteValueCopy(&BandMaster0Pin, &Generated_Pin);
       }

       /* remove generated pin data */
       memset(Generated_Pin.data, 0, Generated_Pin.len);
       Generated_Pin.len = 0; 

       /* remove masterkey */
       memset(MasterKey.data, 0, MasterKey.len);
       MasterKey.len = PIN_SIZE;

     /**************  Encrypt BandMasterPin[X] Completed  ********************/

      /* Set Band on current BandNumber */
      /* we skip Band 0 */
        if (BandNumber == 0) {
          continue;
        }

        /* clear to set buffer */
        toSet = &lastToSet;  
        resetParameters(toSet);

        setStartList(toSet);
        setEndList(toSet);

        setStartList(toSet);
        setStartList(toSet);
 
        /* Set StartLBA value for this BandNumber */
        if (BandNumber > BandSizesCount) {
          StartLBA = 0;
          Band_Length = 0;
        }
        else {
          Band_Length = band_sizes[BandNumber];
        }

        KS_DEBUG(setNamedIntValue(toSet, tcgTmpName("RangeStart"), StartLBA), KS_EAPIABORT, "Range Start Set BandMasterX Return");
        KS_DEBUG(setNamedIntValue(toSet, tcgTmpName("RangeLength"), Band_Length), KS_EAPIABORT, "RangeLength Set BandMasterX Return");
 
        /* Update StartLBA for next iteration of loop */
        StartLBA += Band_Length;

        setEndList(toSet);
        setEndList(toSet);
        KS_DEBUG(issueSet(bandNumberToUID(BandNumber), toSet), KS_EAPIABORT, "Issue Set BandMasterX Return");
      /* Set Band Size Complete */


    /************************  Set BandMaster [X] Pin Completed ********************************/

   } /* end For loop */

   if (Debug_Info == 5) {  /* 5 = keep change  */
     /* if debug set to 5 we leave after BandMasterPins are set up */
     KS_DEBUG(0, KS_INFO, "KS_INITIALIZE:Debug Level 5 [Set BandMasterPin[X] completed  Ending transaction and closing session");
     /* end transaction and close session */
     KS_DEBUG(issueCommitTransaction(), KS_INFO, "DEBUG EXIT 5 Commit");  
     KS_DEBUG(issueCloseSession(), KS_INFO, "DEBUG EXIT 5 Close");
     return KS_DEBUG_EXIT;
   }
   if (Debug_Info == 6) {  /* 6 = abort change  */
     /* if debug set to 6 we leave after BandMasterPins are set up */
     KS_DEBUG(KS_DEBUG_EXIT, KS_ABORT, "KS_INITIALIZE:Debug Level 6 [Set BandMasterPin[X] ABORT] \n");
   }


  /************************  Store DataStore Values Start *****************************************/

  /* Prepare Datastore structure */
  /* put datastore data into a serial byte stream */
  /* Write Datastore structure */
   
   KS_DEBUG(Load_DataStoreString(&DataStoreString, &DataStoreData), KS_ABORT, "Loading Data Store String ");

   toSet = &lastToSet;
   resetParameters(toSet);

   setStartList(toSet);
   setNamedIntValue(toSet, tcgTmpName("startRow"), 0);
   setEndList(toSet);

   setByteValue(toSet, &DataStoreString);  

   /* Need to authenticate as any BandMaster to set the datastore table.  we saved BandMaster0 pin for this purpose */
   KS_DEBUG(issueAuthenticate("BandMaster0", &BandMaster0Pin ), KS_EAPIABORT, "Authenticate BandMaster0 for DataStore Return");  

   /* make call to load the datastore table */
   KS_DEBUG(issueSet(tableNameToUID("DataStore"), toSet), KS_EAPIABORT, "IssueSet DataStore Save Return"); 


  /************************  Store DataStore Values Completed ********************************/


   /* do we want to keep the change and leave or abort the change and leave */ 
   if (Debug_Info == 11) {  /* 11 = abort change  */
     /* if debug set to 9 we leave after datastore save is complete */
     KS_DEBUG(0,KS_INFO,"KS_INITIALIZE:Debug Level 11 [Data Store Save ABORT] \n");
     /* end transaction and close session */

     /* lets print the DataStoreString */
     dumpBuffer(DataStoreString.data, DataStoreString.data+DataStoreString.len);

     KS_DEBUG(issueAbortTransaction(), KS_INFO, "DEBUG EXIT 11 Abort");
     KS_DEBUG(issueCloseSession(), KS_INFO, "DEBUG EXIT 11 Close");
     return KS_DEBUG_EXIT;
   }


  /*********** We are all done with the main tasks commit these and close session ************/

  if (Debug_Info == 12){
    KS_DEBUG(0,KS_INFO,"KS_INITIALIZE:Debug [Store DataStore Values 12 ] completion Close & Exit\n"); 
    /* end transaction and close session */
    KS_DEBUG(issueCommitTransaction(), KS_INFO, "DEBUG EXIT 12 Commit");
    KS_DEBUG(issueCloseSession(), KS_INFO, "DEBUG EXIT 12 Close");

    if(Debug_Info > 49){
      /* lets print the DataStoreString */
      dumpBuffer(DataStoreString.data, DataStoreString.data+DataStoreString.len);
    }

    return KS_DEBUG_EXIT;
   }

   /* clear out datastore string */
   memset(&DataStoreString.data, 0, MAX_DATASTORE_SIZE);

  /* Commit the Erasemaster/BandMaster Pins and datastore */
   KS_DEBUG(issueCommitTransaction(), KS_INFO, "Commit Transaction EM/BM");

  /* Close the session for the Erasemaster/Bandmaster Pin and DataStore */ 
   KS_DEBUG(issueCloseSession(), KS_INFO, "Close Session EM/BM");
 
  /************************  Set SID Pin Start ***********************************************/
 
  /* Now Finally Change SID value */
    /*  start session --  issueStartSession
       get MSID  ------  MSID is in global msidPin
       authenticate as SID authority  ---  issueAuthenticate
       Set SID authority password to a new value   --- issueSet
       encrypt SID pin with NULL password and store in DataStore structure.
       end session  -- session stays open since we have other things to do.
    */
  
   /* open a new session under Admin SP and start a new transaction */
   KS_DEBUG(issueStartSession("AdminSP"), KS_INFO, "Start Session AdminSP");  /* we will do initialize as Admin */
   KS_DEBUG(issueStartTransaction(), KS_CLOSE, "Start Transaction");

#ifdef NOENCSID
   Generated_Pin.len = PIN_SIZE; /* Our pins are always 32 that we generate */
   KS_DEBUG(issueRandom((int)Generated_Pin.len, (char *)Generated_Pin.data), KS_EAPIABORT, "Issue Random for SID");  
#endif
   /* We are keeping msidPin as the pin for SID for now */
   Generated_Pin = msidPin;

   toSet  = &lastToSet;  
   resetParameters(toSet);  /* get clean parameter list */
 
   /* we are setting SID */
   KS_DEBUG(issueAuthenticate("SID", &msidPin ), KS_EAPIABORT, "Authenticate SID");  /* old pin is MSID */

   /* Empty cell_block - cell_block does not apply to Set on Objects */
   setStartList(toSet);
   setEndList(toSet);

   /* Values - list of list of Column-name/value named-pairs */
   setStartList(toSet);
   setStartList(toSet);
   KS_DEBUG(setNamedByteValue(toSet, tcgTmpName("PIN"), &Generated_Pin), KS_EAPIABORT, "Set Named Byte SID PIN");

   setEndList(toSet);
   setEndList(toSet);

   KS_DEBUG(issueSet(pinNameToUID("SID"), toSet), KS_EAPIABORT, "Issue SID Set");

/*
   if (Debug_Info >= DEBUG_CRYPTO) {
     // print the pin for SID so we can see it 
     printf("KS_INITIALIZE:Debug [Set SID PIN] completion\n \
               SID PIN = %s\n",tcgByteValueDebugAllHexStr(&Generated_Pin));
   }
*/

   if (Debug_Info == 13) {  /* 13 = abort change  */
     /* if debug set to 11 we leave after SID PIN change is complete */
     KS_DEBUG(0,KS_INFO,"KS_INITIALIZE:Debug Level 13 [SID PIN Change] ABORT\n");
     /* end transaction and close session */
     KS_DEBUG(issueAbortTransaction(), KS_INFO, "DEBUG EXIT 13 Abort");
     KS_DEBUG(issueCloseSession(), KS_INFO, "DEBUG EXIT 13 Close");
     return KS_DEBUG_EXIT;
   }

   KS_DEBUG(issueCommitTransaction(), KS_CLOSE, "Set SID PIN Commit"); 
   KS_DEBUG(issueCloseSession(), KS_INFO, "Set SID PIN Close");

   /************************  Set SID Pin Completed ********************************/


   /************************  Update DataStore with Encrypted SID Pin Start **********************************/

   /* open a new session under LOCKING SP and start a new transaction */
   KS_DEBUG(issueStartSession("LockingSP"), KS_INFO, "Start Session LockingSP (Store SID)");
   KS_DEBUG(issueStartTransaction(), KS_CLOSE, "Start Transaction LockingSp (Store SID)");

   /***************  Encrypt SID Pin Start  *********************/

   /* Encrypt SID pin with NULL password and store encrypted pin, SALT and TAG in data store structure */

     /* generate a new SALT */
     KS_DEBUG(issueRandom((int)SALT_SIZE,(char *)DataStoreData.SaltSID), KS_EAPIABORT,"Created new SALT for SID");

     /* generate a master Key (SALT, IV, new_pin) */
     KS_DEBUG((PBKDF( (uint8 *)PBKDF_NULL, 
                      (uint32 )0,
                      (uint8* )DataStoreData.SaltSID,
                      (uint32 )SALT_SIZE,
                      (uint32 )ITERATION_COUNT, 
                      (uint16 )MasterKey.len, 
                      (uint8 *)MasterKey.data) -1), KS_ABORT, "Generated NEW Master Key"); 
  
     /* Now GCM_Encrypt with new_pin (master key, IV, unencyrpted_pin) --> TAG, encrypted_pin */
     GCM_Error  = EncryptGCM_Mode( (uint8 *)Generated_Pin.data, PIN_SIZE, 
                                   (uint8 *)PBKDF_NULL, 0, \
                                   (uint8 *)DataStoreData.IV, IV_SIZE,\
                                   (uint8 *)MasterKey.data, MasterKey.len, \
                                   (uint8 *)DataStoreData.SIDPin, &Pin_Length, \
                                   (uint8 *)DataStoreData.TagSID, &Tag_Length );

     if ((GCM_Error > 0 ) || (Pin_Length != PIN_SIZE) || (Tag_Length != TAG_SIZE)) {
       KS_DEBUG(GCM_Error, KS_ABORT, "ENCRYPTGCM failure SID");
     }
/*
     if (Debug_Info >= DEBUG_CRYPTO)  {
       tcgByteValueFromStringCount(&Temp_val, (char *)DataStoreData.SIDPin, (unsigned int) Pin_Length); 
       printf("  Raw SID PIN        = %s\n ",tcgByteValueDebugAllHexStr(&Generated_Pin) );
       printf("  Encrypted SID PIN  = %s\n ",tcgByteValueDebugAllHexStr(&Temp_val) );
     }
*/
     /* data store structure should have SIDPin, SaltSID, TagSID and IV loaded */

     /* remove masterkey, generated pin data */
     memset(MasterKey.data, 0, MasterKey.len);
     MasterKey.len = 0;
     memset(Generated_Pin.data, 0, Generated_Pin.len);
     Generated_Pin.len = 0;

   /**************  Encrypt SID Pin Completed  ********************/
 
   /* recreate datastore long string then convert to tcgByteValue type */
   KS_DEBUG(Load_DataStoreString(&DataStoreString, &DataStoreData), KS_ABORT, "Loading Data Store String ");
 
/*
   if (Debug_Info >= DEBUG_CRYPTO) { //Datastore string
     dumpBuffer(DataStoreString.data, DataStoreString.data+DataStoreString.len);
   }
*/


   /* now set up and load the tcg command */
   tcgByteValueFromStringCount(&tcgDataStore, (char *)DataStoreString.data, DataStoreString.len);

   toSet = &lastToSet;
   resetParameters(toSet);

   setStartList(toSet);
   setNamedIntValue(toSet, tcgTmpName("startRow"), 0);
   setEndList(toSet);

   setByteValue(toSet, &tcgDataStore);  

   /* Use BandMaster 0 to authenticate */
   KS_DEBUG(issueAuthenticate("BandMaster0", &BandMaster0Pin ), KS_EAPIABORT, "Authenticate With BandMaster 0 Datastore prep");  

   KS_DEBUG(issueSet(tableNameToUID("DataStore"), toSet), KS_EAPIABORT, "Issue Set Data Store Completed (SID)");  /* make call to load the datastore table */

   /* clear out datastore string */
   memset(&DataStoreString.data, 0, MAX_DATASTORE_SIZE);

   KS_DEBUG(issueCommitTransaction(), KS_CLOSE, "Update DataStore Commit Transaction"); 
   KS_DEBUG(issueCloseSession(), KS_INFO, "Update DataStore Close Session");


   KS_DEBUG(0,KS_INFO,"KS_INITIALIZE:Debug [Set SID PIN] In Data Store completion");

   /************************  Update DataStore with SID Pin Completed ********************************/

  KS_DEBUG(0,KS_INFO,"KS_INITIALIZE return SUCCESS");
  return KS_SUCCESS;
} /* end of ks_intialize */


/******************************************************************************************************/










