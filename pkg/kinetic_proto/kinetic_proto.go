/*
 * Copyright (c) 2023 Seagate Technology LLC and/or its Affiliates
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kinetic_client.proto

package kinetic_proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The Message Type determines how the the message is to be processed.
type Message_AuthType int32

const (
	// if the message type is unknown, close the connection
	Message_INVALID_AUTH_TYPE Message_AuthType = -1
	// This is for normal traffic. Check the HMAC of the command and
	// if correct, process the command.
	Message_HMACAUTH Message_AuthType = 1
	// device unlock and ISE command. These must come over the TLS connection.
	// If they do not, close the connection. If it is over
	// the TLS connection, execute the pin operation.
	Message_PINAUTH Message_AuthType = 2
	// In the event that the device needs to communicate with the user
	Message_UNSOLICITEDSTATUS Message_AuthType = 3
)

var Message_AuthType_name = map[int32]string{
	-1: "INVALID_AUTH_TYPE",
	1:  "HMACAUTH",
	2:  "PINAUTH",
	3:  "UNSOLICITEDSTATUS",
}

var Message_AuthType_value = map[string]int32{
	"INVALID_AUTH_TYPE": -1,
	"HMACAUTH":          1,
	"PINAUTH":           2,
	"UNSOLICITEDSTATUS": 3,
}

func (x Message_AuthType) Enum() *Message_AuthType {
	p := new(Message_AuthType)
	*p = x
	return p
}

func (x Message_AuthType) String() string {
	return proto.EnumName(Message_AuthType_name, int32(x))
}

func (x *Message_AuthType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Message_AuthType_value, data, "Message_AuthType")
	if err != nil {
		return err
	}
	*x = Message_AuthType(value)
	return nil
}

func (Message_AuthType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{1, 0}
}

type Command_Synchronization int32

const (
	Command_INVALID_SYNCHRONIZATION Command_Synchronization = -1
	Command_WRITETHROUGH            Command_Synchronization = 1
	Command_WRITEBACK               Command_Synchronization = 2
	Command_FLUSH                   Command_Synchronization = 3
)

var Command_Synchronization_name = map[int32]string{
	-1: "INVALID_SYNCHRONIZATION",
	1:  "WRITETHROUGH",
	2:  "WRITEBACK",
	3:  "FLUSH",
}

var Command_Synchronization_value = map[string]int32{
	"INVALID_SYNCHRONIZATION": -1,
	"WRITETHROUGH":            1,
	"WRITEBACK":               2,
	"FLUSH":                   3,
}

func (x Command_Synchronization) Enum() *Command_Synchronization {
	p := new(Command_Synchronization)
	*p = x
	return p
}

func (x Command_Synchronization) String() string {
	return proto.EnumName(Command_Synchronization_name, int32(x))
}

func (x *Command_Synchronization) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Synchronization_value, data, "Command_Synchronization")
	if err != nil {
		return err
	}
	*x = Command_Synchronization(value)
	return nil
}

func (Command_Synchronization) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 0}
}

type Command_Priority int32

const (
	Command_NORMAL       Command_Priority = 5
	Command_LOWEST       Command_Priority = 1
	Command_LOWER        Command_Priority = 2
	Command_LOW          Command_Priority = 3
	Command_LOWERNORMAL  Command_Priority = 4
	Command_HIGHERNORMAL Command_Priority = 6
	Command_HIGH         Command_Priority = 7
	Command_HIGHER       Command_Priority = 8
	Command_HIGHEST      Command_Priority = 9
)

var Command_Priority_name = map[int32]string{
	5: "NORMAL",
	1: "LOWEST",
	2: "LOWER",
	3: "LOW",
	4: "LOWERNORMAL",
	6: "HIGHERNORMAL",
	7: "HIGH",
	8: "HIGHER",
	9: "HIGHEST",
}

var Command_Priority_value = map[string]int32{
	"NORMAL":       5,
	"LOWEST":       1,
	"LOWER":        2,
	"LOW":          3,
	"LOWERNORMAL":  4,
	"HIGHERNORMAL": 6,
	"HIGH":         7,
	"HIGHER":       8,
	"HIGHEST":      9,
}

func (x Command_Priority) Enum() *Command_Priority {
	p := new(Command_Priority)
	*p = x
	return p
}

func (x Command_Priority) String() string {
	return proto.EnumName(Command_Priority_name, int32(x))
}

func (x *Command_Priority) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Priority_value, data, "Command_Priority")
	if err != nil {
		return err
	}
	*x = Command_Priority(value)
	return nil
}

func (Command_Priority) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 1}
}

//algorithm
type Command_Algorithm int32

const (
	Command_INVALID_ALGORITHM Command_Algorithm = -1
	Command_SHA1              Command_Algorithm = 1
	Command_SHA2              Command_Algorithm = 2
	Command_SHA3              Command_Algorithm = 3
	Command_CRC32C            Command_Algorithm = 4
	Command_CRC64             Command_Algorithm = 5
	Command_CRC32             Command_Algorithm = 6
)

var Command_Algorithm_name = map[int32]string{
	-1: "INVALID_ALGORITHM",
	1:  "SHA1",
	2:  "SHA2",
	3:  "SHA3",
	4:  "CRC32C",
	5:  "CRC64",
	6:  "CRC32",
}

var Command_Algorithm_value = map[string]int32{
	"INVALID_ALGORITHM": -1,
	"SHA1":              1,
	"SHA2":              2,
	"SHA3":              3,
	"CRC32C":            4,
	"CRC64":             5,
	"CRC32":             6,
}

func (x Command_Algorithm) Enum() *Command_Algorithm {
	p := new(Command_Algorithm)
	*p = x
	return p
}

func (x Command_Algorithm) String() string {
	return proto.EnumName(Command_Algorithm_name, int32(x))
}

func (x *Command_Algorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Algorithm_value, data, "Command_Algorithm")
	if err != nil {
		return err
	}
	*x = Command_Algorithm(value)
	return nil
}

func (Command_Algorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 2}
}

//operation code
type Command_MessageType int32

const (
	Command_INVALID_MESSAGE_TYPE Command_MessageType = -1
	Command_GET                  Command_MessageType = 2
	Command_GET_RESPONSE         Command_MessageType = 1
	Command_PUT                  Command_MessageType = 4
	Command_PUT_RESPONSE         Command_MessageType = 3
	Command_DELETE               Command_MessageType = 6
	Command_DELETE_RESPONSE      Command_MessageType = 5
	Command_GETNEXT              Command_MessageType = 8
	Command_GETNEXT_RESPONSE     Command_MessageType = 7
	Command_GETPREVIOUS          Command_MessageType = 10
	Command_GETPREVIOUS_RESPONSE Command_MessageType = 9
	Command_GETKEYRANGE          Command_MessageType = 12
	Command_GETKEYRANGE_RESPONSE Command_MessageType = 11
	// 13 and 14 are reserved, do not use
	Command_GETVERSION          Command_MessageType = 16
	Command_GETVERSION_RESPONSE Command_MessageType = 15
	// 17, 18, 19, and 20 are reserved, do not use
	Command_SETUP                  Command_MessageType = 22
	Command_SETUP_RESPONSE         Command_MessageType = 21
	Command_GETLOG                 Command_MessageType = 24
	Command_GETLOG_RESPONSE        Command_MessageType = 23
	Command_SECURITY               Command_MessageType = 26
	Command_SECURITY_RESPONSE      Command_MessageType = 25
	Command_PEER2PEERPUSH          Command_MessageType = 28
	Command_PEER2PEERPUSH_RESPONSE Command_MessageType = 27
	Command_NOOP                   Command_MessageType = 30
	Command_NOOP_RESPONSE          Command_MessageType = 29
	Command_FLUSHALLDATA           Command_MessageType = 32
	Command_FLUSHALLDATA_RESPONSE  Command_MessageType = 31
	// 33, 34 are reserved
	Command_PINOP          Command_MessageType = 36
	Command_PINOP_RESPONSE Command_MessageType = 35
	// Media scan is to check that the user data is readable, and
	// if the end to end integrity is known to the device, if the
	// end to end integrity field is correct.
	Command_MEDIASCAN          Command_MessageType = 38
	Command_MEDIASCAN_RESPONSE Command_MessageType = 37
	// This performs optimizations of the media. Things like
	// defragmentation, compaction, garbage collection, compression
	// could be things accomplished using the media optimize command.
	Command_MEDIAOPTIMIZE          Command_MessageType = 40
	Command_MEDIAOPTIMIZE_RESPONSE Command_MessageType = 39
	// batch operations
	Command_START_BATCH          Command_MessageType = 42
	Command_START_BATCH_RESPONSE Command_MessageType = 41
	Command_END_BATCH            Command_MessageType = 44
	Command_END_BATCH_RESPONSE   Command_MessageType = 43
	Command_ABORT_BATCH          Command_MessageType = 46
	Command_ABORT_BATCH_RESPONSE Command_MessageType = 45
	// power management
	Command_SET_POWER_LEVEL          Command_MessageType = 48
	Command_SET_POWER_LEVEL_RESPONSE Command_MessageType = 47
)

var Command_MessageType_name = map[int32]string{
	-1: "INVALID_MESSAGE_TYPE",
	2:  "GET",
	1:  "GET_RESPONSE",
	4:  "PUT",
	3:  "PUT_RESPONSE",
	6:  "DELETE",
	5:  "DELETE_RESPONSE",
	8:  "GETNEXT",
	7:  "GETNEXT_RESPONSE",
	10: "GETPREVIOUS",
	9:  "GETPREVIOUS_RESPONSE",
	12: "GETKEYRANGE",
	11: "GETKEYRANGE_RESPONSE",
	16: "GETVERSION",
	15: "GETVERSION_RESPONSE",
	22: "SETUP",
	21: "SETUP_RESPONSE",
	24: "GETLOG",
	23: "GETLOG_RESPONSE",
	26: "SECURITY",
	25: "SECURITY_RESPONSE",
	28: "PEER2PEERPUSH",
	27: "PEER2PEERPUSH_RESPONSE",
	30: "NOOP",
	29: "NOOP_RESPONSE",
	32: "FLUSHALLDATA",
	31: "FLUSHALLDATA_RESPONSE",
	36: "PINOP",
	35: "PINOP_RESPONSE",
	38: "MEDIASCAN",
	37: "MEDIASCAN_RESPONSE",
	40: "MEDIAOPTIMIZE",
	39: "MEDIAOPTIMIZE_RESPONSE",
	42: "START_BATCH",
	41: "START_BATCH_RESPONSE",
	44: "END_BATCH",
	43: "END_BATCH_RESPONSE",
	46: "ABORT_BATCH",
	45: "ABORT_BATCH_RESPONSE",
	48: "SET_POWER_LEVEL",
	47: "SET_POWER_LEVEL_RESPONSE",
}

var Command_MessageType_value = map[string]int32{
	"INVALID_MESSAGE_TYPE":     -1,
	"GET":                      2,
	"GET_RESPONSE":             1,
	"PUT":                      4,
	"PUT_RESPONSE":             3,
	"DELETE":                   6,
	"DELETE_RESPONSE":          5,
	"GETNEXT":                  8,
	"GETNEXT_RESPONSE":         7,
	"GETPREVIOUS":              10,
	"GETPREVIOUS_RESPONSE":     9,
	"GETKEYRANGE":              12,
	"GETKEYRANGE_RESPONSE":     11,
	"GETVERSION":               16,
	"GETVERSION_RESPONSE":      15,
	"SETUP":                    22,
	"SETUP_RESPONSE":           21,
	"GETLOG":                   24,
	"GETLOG_RESPONSE":          23,
	"SECURITY":                 26,
	"SECURITY_RESPONSE":        25,
	"PEER2PEERPUSH":            28,
	"PEER2PEERPUSH_RESPONSE":   27,
	"NOOP":                     30,
	"NOOP_RESPONSE":            29,
	"FLUSHALLDATA":             32,
	"FLUSHALLDATA_RESPONSE":    31,
	"PINOP":                    36,
	"PINOP_RESPONSE":           35,
	"MEDIASCAN":                38,
	"MEDIASCAN_RESPONSE":       37,
	"MEDIAOPTIMIZE":            40,
	"MEDIAOPTIMIZE_RESPONSE":   39,
	"START_BATCH":              42,
	"START_BATCH_RESPONSE":     41,
	"END_BATCH":                44,
	"END_BATCH_RESPONSE":       43,
	"ABORT_BATCH":              46,
	"ABORT_BATCH_RESPONSE":     45,
	"SET_POWER_LEVEL":          48,
	"SET_POWER_LEVEL_RESPONSE": 47,
}

func (x Command_MessageType) Enum() *Command_MessageType {
	p := new(Command_MessageType)
	*p = x
	return p
}

func (x Command_MessageType) String() string {
	return proto.EnumName(Command_MessageType_name, int32(x))
}

func (x *Command_MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_MessageType_value, data, "Command_MessageType")
	if err != nil {
		return err
	}
	*x = Command_MessageType(value)
	return nil
}

func (Command_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 3}
}

type Command_PowerLevel int32

const (
	Command_INVALID_LEVEL Command_PowerLevel = -1
	Command_OPERATIONAL   Command_PowerLevel = 1
	Command_HIBERNATE     Command_PowerLevel = 2
	Command_SHUTDOWN      Command_PowerLevel = 3
	Command_FAIL          Command_PowerLevel = 4
)

var Command_PowerLevel_name = map[int32]string{
	-1: "INVALID_LEVEL",
	1:  "OPERATIONAL",
	2:  "HIBERNATE",
	3:  "SHUTDOWN",
	4:  "FAIL",
}

var Command_PowerLevel_value = map[string]int32{
	"INVALID_LEVEL": -1,
	"OPERATIONAL":   1,
	"HIBERNATE":     2,
	"SHUTDOWN":      3,
	"FAIL":          4,
}

func (x Command_PowerLevel) Enum() *Command_PowerLevel {
	p := new(Command_PowerLevel)
	*p = x
	return p
}

func (x Command_PowerLevel) String() string {
	return proto.EnumName(Command_PowerLevel_name, int32(x))
}

func (x *Command_PowerLevel) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_PowerLevel_value, data, "Command_PowerLevel")
	if err != nil {
		return err
	}
	*x = Command_PowerLevel(value)
	return nil
}

func (Command_PowerLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 4}
}

//enum of status code
type Command_Status_StatusCode int32

const (
	// Must come first, so default is invalid
	Command_Status_INVALID_STATUS_CODE Command_Status_StatusCode = -1
	//  for a P2P operation, there was a reason the list was incomplete. This is for items
	// that were not attempted.
	Command_Status_NOT_ATTEMPTED    Command_Status_StatusCode = 0
	Command_Status_SUCCESS          Command_Status_StatusCode = 1
	Command_Status_HMAC_FAILURE     Command_Status_StatusCode = 2
	Command_Status_NOT_AUTHORIZED   Command_Status_StatusCode = 3
	Command_Status_VERSION_FAILURE  Command_Status_StatusCode = 4
	Command_Status_INTERNAL_ERROR   Command_Status_StatusCode = 5
	Command_Status_HEADER_REQUIRED  Command_Status_StatusCode = 6
	Command_Status_NOT_FOUND        Command_Status_StatusCode = 7
	Command_Status_VERSION_MISMATCH Command_Status_StatusCode = 8
	// If there are too many requests in the device at this time, requests
	// will be rejected with this error message. The common response is to
	// wait and retry the operation with an exponential back-off.
	Command_Status_SERVICE_BUSY Command_Status_StatusCode = 9
	// A long operation was started and a timeout happened mid operation. This
	// does not imply a failure.
	Command_Status_EXPIRED Command_Status_StatusCode = 10
	// A data error happened and either earlyExit was set or the timeout happened.
	Command_Status_DATA_ERROR Command_Status_StatusCode = 11
	// A data error happened and all possible error recovery operations have been
	// performed. There is no value to trying this again. If the system has the ability
	// to determine the correct information, writing the data again can get rid
	Command_Status_PERM_DATA_ERROR Command_Status_StatusCode = 12
	// A TCP connection to the remote peer failed. This is only for the P2P Operation
	Command_Status_REMOTE_CONNECTION_ERROR Command_Status_StatusCode = 13
	// When the device is full, it returns this error. The background scrubbing may free space,
	// so this error may go away
	Command_Status_NO_SPACE Command_Status_StatusCode = 14
	// In the set security, an HmacAlgorithm was specified as Unknown or there is a protocol
	// version mis-match
	Command_Status_NO_SUCH_HMAC_ALGORITHM Command_Status_StatusCode = 15
	// The request is not valid. Subsequent attempts with the same request will return the same code.
	// Example: PUT a key whose size exceeds the specified maxKeySize in limits.
	Command_Status_INVALID_REQUEST Command_Status_StatusCode = 16
	// For P2P Requests, the operation was executed successfully but some nested operations
	// did not succeed. This indicates that callers should review the status of nested operations.
	// This status should only be used in the Command > Status, not in the Status messages
	// of nested P2POperations
	Command_Status_NESTED_OPERATION_ERRORS Command_Status_StatusCode = 17
	// If the device is currently locked
	Command_Status_DEVICE_LOCKED Command_Status_StatusCode = 18
	// The device is already unlocked.
	Command_Status_DEVICE_ALREADY_UNLOCKED Command_Status_StatusCode = 19
	// The connection is being terminated. Details as to why are
	// in the message string.
	Command_Status_CONNECTION_TERMINATED Command_Status_StatusCode = 20
	// The batch request is not valid. Subsequent attempts with the same batch request will return the
	// same code. Example: A batch that contains a command other than put or delete.
	Command_Status_INVALID_BATCH Command_Status_StatusCode = 21
	// the status is returned to caller if commands are received when
	// device is in hibernate state
	Command_Status_HIBERNATE Command_Status_StatusCode = 22
	// the status is returned to caller if commands are received when
	// device is shutting down.
	Command_Status_SHUTDOWN Command_Status_StatusCode = 23
)

var Command_Status_StatusCode_name = map[int32]string{
	-1: "INVALID_STATUS_CODE",
	0:  "NOT_ATTEMPTED",
	1:  "SUCCESS",
	2:  "HMAC_FAILURE",
	3:  "NOT_AUTHORIZED",
	4:  "VERSION_FAILURE",
	5:  "INTERNAL_ERROR",
	6:  "HEADER_REQUIRED",
	7:  "NOT_FOUND",
	8:  "VERSION_MISMATCH",
	9:  "SERVICE_BUSY",
	10: "EXPIRED",
	11: "DATA_ERROR",
	12: "PERM_DATA_ERROR",
	13: "REMOTE_CONNECTION_ERROR",
	14: "NO_SPACE",
	15: "NO_SUCH_HMAC_ALGORITHM",
	16: "INVALID_REQUEST",
	17: "NESTED_OPERATION_ERRORS",
	18: "DEVICE_LOCKED",
	19: "DEVICE_ALREADY_UNLOCKED",
	20: "CONNECTION_TERMINATED",
	21: "INVALID_BATCH",
	22: "HIBERNATE",
	23: "SHUTDOWN",
}

var Command_Status_StatusCode_value = map[string]int32{
	"INVALID_STATUS_CODE":     -1,
	"NOT_ATTEMPTED":           0,
	"SUCCESS":                 1,
	"HMAC_FAILURE":            2,
	"NOT_AUTHORIZED":          3,
	"VERSION_FAILURE":         4,
	"INTERNAL_ERROR":          5,
	"HEADER_REQUIRED":         6,
	"NOT_FOUND":               7,
	"VERSION_MISMATCH":        8,
	"SERVICE_BUSY":            9,
	"EXPIRED":                 10,
	"DATA_ERROR":              11,
	"PERM_DATA_ERROR":         12,
	"REMOTE_CONNECTION_ERROR": 13,
	"NO_SPACE":                14,
	"NO_SUCH_HMAC_ALGORITHM":  15,
	"INVALID_REQUEST":         16,
	"NESTED_OPERATION_ERRORS": 17,
	"DEVICE_LOCKED":           18,
	"DEVICE_ALREADY_UNLOCKED": 19,
	"CONNECTION_TERMINATED":   20,
	"INVALID_BATCH":           21,
	"HIBERNATE":               22,
	"SHUTDOWN":                23,
}

func (x Command_Status_StatusCode) Enum() *Command_Status_StatusCode {
	p := new(Command_Status_StatusCode)
	*p = x
	return p
}

func (x Command_Status_StatusCode) String() string {
	return proto.EnumName(Command_Status_StatusCode_name, int32(x))
}

func (x *Command_Status_StatusCode) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Status_StatusCode_value, data, "Command_Status_StatusCode")
	if err != nil {
		return err
	}
	*x = Command_Status_StatusCode(value)
	return nil
}

func (Command_Status_StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 4, 0}
}

type Command_Setup_SetupOpType int32

const (
	Command_Setup_INVALID_SETUPOP Command_Setup_SetupOpType = -1
	// This setup command is to issue a firmware update
	// There is a firmware load in the data portion of this message.
	// The firmware is itself protected on its own for integrity,
	// authenticity, etc.
	Command_Setup_FIRMWARE_SETUPOP Command_Setup_SetupOpType = 1
	// This setup command is to update the cluster version
	Command_Setup_CLUSTER_VERSION_SETUPOP Command_Setup_SetupOpType = 2
)

var Command_Setup_SetupOpType_name = map[int32]string{
	-1: "INVALID_SETUPOP",
	1:  "FIRMWARE_SETUPOP",
	2:  "CLUSTER_VERSION_SETUPOP",
}

var Command_Setup_SetupOpType_value = map[string]int32{
	"INVALID_SETUPOP":         -1,
	"FIRMWARE_SETUPOP":        1,
	"CLUSTER_VERSION_SETUPOP": 2,
}

func (x Command_Setup_SetupOpType) Enum() *Command_Setup_SetupOpType {
	p := new(Command_Setup_SetupOpType)
	*p = x
	return p
}

func (x Command_Setup_SetupOpType) String() string {
	return proto.EnumName(Command_Setup_SetupOpType_name, int32(x))
}

func (x *Command_Setup_SetupOpType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Setup_SetupOpType_value, data, "Command_Setup_SetupOpType")
	if err != nil {
		return err
	}
	*x = Command_Setup_SetupOpType(value)
	return nil
}

func (Command_Setup_SetupOpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 7, 0}
}

type Command_GetLog_Type int32

const (
	Command_GetLog_INVALID_TYPE  Command_GetLog_Type = -1
	Command_GetLog_UTILIZATIONS  Command_GetLog_Type = 0
	Command_GetLog_TEMPERATURES  Command_GetLog_Type = 1
	Command_GetLog_CAPACITIES    Command_GetLog_Type = 2
	Command_GetLog_CONFIGURATION Command_GetLog_Type = 3
	Command_GetLog_STATISTICS    Command_GetLog_Type = 4
	Command_GetLog_MESSAGES      Command_GetLog_Type = 5
	Command_GetLog_LIMITS        Command_GetLog_Type = 6
	Command_GetLog_DEVICE        Command_GetLog_Type = 7
)

var Command_GetLog_Type_name = map[int32]string{
	-1: "INVALID_TYPE",
	0:  "UTILIZATIONS",
	1:  "TEMPERATURES",
	2:  "CAPACITIES",
	3:  "CONFIGURATION",
	4:  "STATISTICS",
	5:  "MESSAGES",
	6:  "LIMITS",
	7:  "DEVICE",
}

var Command_GetLog_Type_value = map[string]int32{
	"INVALID_TYPE":  -1,
	"UTILIZATIONS":  0,
	"TEMPERATURES":  1,
	"CAPACITIES":    2,
	"CONFIGURATION": 3,
	"STATISTICS":    4,
	"MESSAGES":      5,
	"LIMITS":        6,
	"DEVICE":        7,
}

func (x Command_GetLog_Type) Enum() *Command_GetLog_Type {
	p := new(Command_GetLog_Type)
	*p = x
	return p
}

func (x Command_GetLog_Type) String() string {
	return proto.EnumName(Command_GetLog_Type_name, int32(x))
}

func (x *Command_GetLog_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_GetLog_Type_value, data, "Command_GetLog_Type")
	if err != nil {
		return err
	}
	*x = Command_GetLog_Type(value)
	return nil
}

func (Command_GetLog_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 0}
}

type Command_Security_SecurityOpType int32

const (
	Command_Security_INVALID_SECURITYOP Command_Security_SecurityOpType = -1
	// This security command is to set up ACL identities
	Command_Security_ACL_SECURITYOP Command_Security_SecurityOpType = 1
	// This security command is to set the erase pin
	Command_Security_ERASE_PIN_SECURITYOP Command_Security_SecurityOpType = 2
	// This security command is to set the lock pin
	Command_Security_LOCK_PIN_SECURITYOP Command_Security_SecurityOpType = 3
)

var Command_Security_SecurityOpType_name = map[int32]string{
	-1: "INVALID_SECURITYOP",
	1:  "ACL_SECURITYOP",
	2:  "ERASE_PIN_SECURITYOP",
	3:  "LOCK_PIN_SECURITYOP",
}

var Command_Security_SecurityOpType_value = map[string]int32{
	"INVALID_SECURITYOP":   -1,
	"ACL_SECURITYOP":       1,
	"ERASE_PIN_SECURITYOP": 2,
	"LOCK_PIN_SECURITYOP":  3,
}

func (x Command_Security_SecurityOpType) Enum() *Command_Security_SecurityOpType {
	p := new(Command_Security_SecurityOpType)
	*p = x
	return p
}

func (x Command_Security_SecurityOpType) String() string {
	return proto.EnumName(Command_Security_SecurityOpType_name, int32(x))
}

func (x *Command_Security_SecurityOpType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Security_SecurityOpType_value, data, "Command_Security_SecurityOpType")
	if err != nil {
		return err
	}
	*x = Command_Security_SecurityOpType(value)
	return nil
}

func (Command_Security_SecurityOpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 10, 0}
}

type Command_Security_ACL_HMACAlgorithm int32

const (
	Command_Security_ACL_INVALID_HMAC_ALGORITHM Command_Security_ACL_HMACAlgorithm = -1
	// 0 is reserved; do not use
	Command_Security_ACL_HmacSHA1 Command_Security_ACL_HMACAlgorithm = 1
)

var Command_Security_ACL_HMACAlgorithm_name = map[int32]string{
	-1: "INVALID_HMAC_ALGORITHM",
	1:  "HmacSHA1",
}

var Command_Security_ACL_HMACAlgorithm_value = map[string]int32{
	"INVALID_HMAC_ALGORITHM": -1,
	"HmacSHA1":               1,
}

func (x Command_Security_ACL_HMACAlgorithm) Enum() *Command_Security_ACL_HMACAlgorithm {
	p := new(Command_Security_ACL_HMACAlgorithm)
	*p = x
	return p
}

func (x Command_Security_ACL_HMACAlgorithm) String() string {
	return proto.EnumName(Command_Security_ACL_HMACAlgorithm_name, int32(x))
}

func (x *Command_Security_ACL_HMACAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Security_ACL_HMACAlgorithm_value, data, "Command_Security_ACL_HMACAlgorithm")
	if err != nil {
		return err
	}
	*x = Command_Security_ACL_HMACAlgorithm(value)
	return nil
}

func (Command_Security_ACL_HMACAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 10, 0, 0}
}

type Command_Security_ACL_Permission int32

const (
	Command_Security_ACL_INVALID_PERMISSION Command_Security_ACL_Permission = -1
	Command_Security_ACL_READ               Command_Security_ACL_Permission = 0
	Command_Security_ACL_WRITE              Command_Security_ACL_Permission = 1
	Command_Security_ACL_DELETE             Command_Security_ACL_Permission = 2
	Command_Security_ACL_RANGE              Command_Security_ACL_Permission = 3
	Command_Security_ACL_SETUP              Command_Security_ACL_Permission = 4
	Command_Security_ACL_P2POP              Command_Security_ACL_Permission = 5
	Command_Security_ACL_GETLOG             Command_Security_ACL_Permission = 7
	Command_Security_ACL_SECURITY           Command_Security_ACL_Permission = 8
	Command_Security_ACL_POWER_MANAGEMENT   Command_Security_ACL_Permission = 9
)

var Command_Security_ACL_Permission_name = map[int32]string{
	-1: "INVALID_PERMISSION",
	0:  "READ",
	1:  "WRITE",
	2:  "DELETE",
	3:  "RANGE",
	4:  "SETUP",
	5:  "P2POP",
	7:  "GETLOG",
	8:  "SECURITY",
	9:  "POWER_MANAGEMENT",
}

var Command_Security_ACL_Permission_value = map[string]int32{
	"INVALID_PERMISSION": -1,
	"READ":               0,
	"WRITE":              1,
	"DELETE":             2,
	"RANGE":              3,
	"SETUP":              4,
	"P2POP":              5,
	"GETLOG":             7,
	"SECURITY":           8,
	"POWER_MANAGEMENT":   9,
}

func (x Command_Security_ACL_Permission) Enum() *Command_Security_ACL_Permission {
	p := new(Command_Security_ACL_Permission)
	*p = x
	return p
}

func (x Command_Security_ACL_Permission) String() string {
	return proto.EnumName(Command_Security_ACL_Permission_name, int32(x))
}

func (x *Command_Security_ACL_Permission) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_Security_ACL_Permission_value, data, "Command_Security_ACL_Permission")
	if err != nil {
		return err
	}
	*x = Command_Security_ACL_Permission(value)
	return nil
}

func (Command_Security_ACL_Permission) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 10, 0, 1}
}

type Command_PinOperation_PinOpType int32

const (
	Command_PinOperation_INVALID_PINOP Command_PinOperation_PinOpType = -1
	// The pin will unlock the device
	Command_PinOperation_UNLOCK_PINOP Command_PinOperation_PinOpType = 1
	// This will lock the device. This includes all
	// configuration and user data. This operation is
	// secure from even given physical access and
	// disassembly of the device.
	Command_PinOperation_LOCK_PINOP Command_PinOperation_PinOpType = 2
	// Erase the device. This may be secure
	// or not. The implication is that it may be faster
	// than the secure operation.
	Command_PinOperation_ERASE_PINOP Command_PinOperation_PinOpType = 3
	// Erase the device in a way that will
	// physical access and disassembly of the device
	// will not
	Command_PinOperation_SECURE_ERASE_PINOP Command_PinOperation_PinOpType = 4
)

var Command_PinOperation_PinOpType_name = map[int32]string{
	-1: "INVALID_PINOP",
	1:  "UNLOCK_PINOP",
	2:  "LOCK_PINOP",
	3:  "ERASE_PINOP",
	4:  "SECURE_ERASE_PINOP",
}

var Command_PinOperation_PinOpType_value = map[string]int32{
	"INVALID_PINOP":      -1,
	"UNLOCK_PINOP":       1,
	"LOCK_PINOP":         2,
	"ERASE_PINOP":        3,
	"SECURE_ERASE_PINOP": 4,
}

func (x Command_PinOperation_PinOpType) Enum() *Command_PinOperation_PinOpType {
	p := new(Command_PinOperation_PinOpType)
	*p = x
	return p
}

func (x Command_PinOperation_PinOpType) String() string {
	return proto.EnumName(Command_PinOperation_PinOpType_name, int32(x))
}

func (x *Command_PinOperation_PinOpType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_PinOperation_PinOpType_value, data, "Command_PinOperation_PinOpType")
	if err != nil {
		return err
	}
	*x = Command_PinOperation_PinOpType(value)
	return nil
}

func (Command_PinOperation_PinOpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 11, 0}
}

// this is a local message to allow the program to read
// the protocol version number by building this message
// and then reading the value.
type Local struct {
	ProtocolVersion      *string  `protobuf:"bytes,1,opt,name=protocolVersion,def=4.0.0" json:"protocolVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Local) Reset()         { *m = Local{} }
func (m *Local) String() string { return proto.CompactTextString(m) }
func (*Local) ProtoMessage()    {}
func (*Local) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{0}
}

func (m *Local) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Local.Unmarshal(m, b)
}
func (m *Local) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Local.Marshal(b, m, deterministic)
}
func (m *Local) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Local.Merge(m, src)
}
func (m *Local) XXX_Size() int {
	return xxx_messageInfo_Local.Size(m)
}
func (m *Local) XXX_DiscardUnknown() {
	xxx_messageInfo_Local.DiscardUnknown(m)
}

var xxx_messageInfo_Local proto.InternalMessageInfo

const Default_Local_ProtocolVersion string = "4.0.0"

func (m *Local) GetProtocolVersion() string {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return Default_Local_ProtocolVersion
}

// THe message is an authorization and command bytes.
type Message struct {
	// Every message must be one of the following types.
	AuthType *Message_AuthType `protobuf:"varint,4,opt,name=authType,enum=kinetic.Message_AuthType" json:"authType,omitempty"`
	// Normal messages
	HmacAuth *Message_HMACauth `protobuf:"bytes,5,opt,name=hmacAuth" json:"hmacAuth,omitempty"`
	// for Pin based operations. These include device unlock and
	// device erase
	PinAuth *Message_PINauth `protobuf:"bytes,6,opt,name=pinAuth" json:"pinAuth,omitempty"`
	// the embedded message providing the request (for HMACauth) and
	// the response (for all auth types).
	CommandBytes         []byte   `protobuf:"bytes,7,opt,name=commandBytes" json:"commandBytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{1}
}

func (m *Message) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Message.Unmarshal(m, b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Message.Marshal(b, m, deterministic)
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return xxx_messageInfo_Message.Size(m)
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetAuthType() Message_AuthType {
	if m != nil && m.AuthType != nil {
		return *m.AuthType
	}
	return Message_INVALID_AUTH_TYPE
}

func (m *Message) GetHmacAuth() *Message_HMACauth {
	if m != nil {
		return m.HmacAuth
	}
	return nil
}

func (m *Message) GetPinAuth() *Message_PINauth {
	if m != nil {
		return m.PinAuth
	}
	return nil
}

func (m *Message) GetCommandBytes() []byte {
	if m != nil {
		return m.CommandBytes
	}
	return nil
}

// This is for normal message to the device
// and for responses. These are allowed once the
// device is unlocked. The HMAC provides for
// authenticity, Integrity and to enforce roles.
type Message_HMACauth struct {
	// The "identity" identifies the requester and the key and algorithm to
	// be used for hmac.
	Identity             *int64   `protobuf:"varint,1,opt,name=identity" json:"identity,omitempty"`
	Hmac                 []byte   `protobuf:"bytes,2,opt,name=hmac" json:"hmac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message_HMACauth) Reset()         { *m = Message_HMACauth{} }
func (m *Message_HMACauth) String() string { return proto.CompactTextString(m) }
func (*Message_HMACauth) ProtoMessage()    {}
func (*Message_HMACauth) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{1, 0}
}

func (m *Message_HMACauth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Message_HMACauth.Unmarshal(m, b)
}
func (m *Message_HMACauth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Message_HMACauth.Marshal(b, m, deterministic)
}
func (m *Message_HMACauth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message_HMACauth.Merge(m, src)
}
func (m *Message_HMACauth) XXX_Size() int {
	return xxx_messageInfo_Message_HMACauth.Size(m)
}
func (m *Message_HMACauth) XXX_DiscardUnknown() {
	xxx_messageInfo_Message_HMACauth.DiscardUnknown(m)
}

var xxx_messageInfo_Message_HMACauth proto.InternalMessageInfo

func (m *Message_HMACauth) GetIdentity() int64 {
	if m != nil && m.Identity != nil {
		return *m.Identity
	}
	return 0
}

func (m *Message_HMACauth) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

// Pin based authentication for Pin operations.
type Message_PINauth struct {
	// The pin necessary to make the operations valid
	Pin                  []byte   `protobuf:"bytes,1,opt,name=pin" json:"pin,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Message_PINauth) Reset()         { *m = Message_PINauth{} }
func (m *Message_PINauth) String() string { return proto.CompactTextString(m) }
func (*Message_PINauth) ProtoMessage()    {}
func (*Message_PINauth) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{1, 1}
}

func (m *Message_PINauth) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Message_PINauth.Unmarshal(m, b)
}
func (m *Message_PINauth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Message_PINauth.Marshal(b, m, deterministic)
}
func (m *Message_PINauth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message_PINauth.Merge(m, src)
}
func (m *Message_PINauth) XXX_Size() int {
	return xxx_messageInfo_Message_PINauth.Size(m)
}
func (m *Message_PINauth) XXX_DiscardUnknown() {
	xxx_messageInfo_Message_PINauth.DiscardUnknown(m)
}

var xxx_messageInfo_Message_PINauth proto.InternalMessageInfo

func (m *Message_PINauth) GetPin() []byte {
	if m != nil {
		return m.Pin
	}
	return nil
}

type Command struct {
	//message header
	Header *Command_Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	//message body
	Body *Command_Body `protobuf:"bytes,2,opt,name=body" json:"body,omitempty"`
	//operation status
	Status               *Command_Status `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2}
}

func (m *Command) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command.Unmarshal(m, b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command.Marshal(b, m, deterministic)
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return xxx_messageInfo_Command.Size(m)
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetHeader() *Command_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Command) GetBody() *Command_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Command) GetStatus() *Command_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

//message header
type Command_Header struct {
	// "cluster" is the  number of the cluster definition. If this is incompatible,
	// the request is rejected. By default the value is 0, allowing systems not
	// using cluster versioning to ignore this field in the header and in the setup.
	ClusterVersion *int64 `protobuf:"varint,1,opt,name=clusterVersion" json:"clusterVersion,omitempty"`
	// A unique number for this connection between the source and target. The device can change this
	// number and the client must continue to use the new number and the number must remain
	// constant during the session.
	ConnectionID *int64 `protobuf:"varint,3,opt,name=connectionID" json:"connectionID,omitempty"`
	// the sequence of this request in this TCP connection. As long as this value is getting larger we have
	// strong ordering and replay prevention within a session. This combined with the time and connectionID
	// provides strong ordering between sessions.
	Sequence *uint64 `protobuf:"varint,4,opt,name=sequence" json:"sequence,omitempty"`
	//co-related sequence
	AckSequence *uint64 `protobuf:"varint,6,opt,name=ackSequence" json:"ackSequence,omitempty"`
	//operation code - put/get/delete/GetLog, etc.
	MessageType *Command_MessageType `protobuf:"varint,7,opt,name=messageType,enum=kinetic.Command_MessageType" json:"messageType,omitempty"`
	// Request timeout (in ms). This is the amount of time that this request should take. If this timeout
	// is triggered, there are three possible results that can be returned.
	//   - SERVICE_BUSY meaning that the request was still on the queue waiting to be executed
	//   - EXPIRED meaning that a long running operation was stopped because the time expired.
	//   - DATA_ERROR meaning that the request was in process, but that the error recovery was not
	//          complete at the time that the time expired
	Timeout *uint64 `protobuf:"varint,9,opt,name=timeout" json:"timeout,omitempty"`
	// If true, requests will not attempt multi revolution recoveries even if the timeout has not occurred.
	// In this case the result will be DATA_ERROR. To have the device exhaust all possible error recovery, leave
	// this field off or set to false, and make sure that the timeout is set to be longer than any possible queue
	// time and error recovery time. On a disk device, the maximum error recovery time could be seconds.
	// Once all possible data recovery operations are complete and have not succeeded, PERM_DATA_ERROR will be
	// returned.
	EarlyExit *bool `protobuf:"varint,10,opt,name=earlyExit" json:"earlyExit,omitempty"`
	// Priority is a simple integer that determines the priority of this
	// request. All activity at a higher priority will execute before that
	// of lower priority traffic. A higher number is higher priority.
	Priority *Command_Priority `protobuf:"varint,12,opt,name=priority,enum=kinetic.Command_Priority" json:"priority,omitempty"`
	// A hint of how long a job should run before yielding. Specified in
	// miliseconds. A value of 0 indicates that the operation can perform one
	// sub operation and then check to see if there are other sub higher
	// priority operations. An example of a sub-operation might be a single put
	// in a P2P operation, etc.
	TimeQuanta *uint64 `protobuf:"varint,13,opt,name=TimeQuanta" json:"TimeQuanta,omitempty"`
	// batch id to be included in each command of a batch operation
	// this id is generated by client library and must be unique
	// within the same connection.
	BatchID              *uint32  `protobuf:"varint,14,opt,name=batchID" json:"batchID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_Header) Reset()         { *m = Command_Header{} }
func (m *Command_Header) String() string { return proto.CompactTextString(m) }
func (*Command_Header) ProtoMessage()    {}
func (*Command_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 0}
}

func (m *Command_Header) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Header.Unmarshal(m, b)
}
func (m *Command_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Header.Marshal(b, m, deterministic)
}
func (m *Command_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Header.Merge(m, src)
}
func (m *Command_Header) XXX_Size() int {
	return xxx_messageInfo_Command_Header.Size(m)
}
func (m *Command_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Header proto.InternalMessageInfo

func (m *Command_Header) GetClusterVersion() int64 {
	if m != nil && m.ClusterVersion != nil {
		return *m.ClusterVersion
	}
	return 0
}

func (m *Command_Header) GetConnectionID() int64 {
	if m != nil && m.ConnectionID != nil {
		return *m.ConnectionID
	}
	return 0
}

func (m *Command_Header) GetSequence() uint64 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *Command_Header) GetAckSequence() uint64 {
	if m != nil && m.AckSequence != nil {
		return *m.AckSequence
	}
	return 0
}

func (m *Command_Header) GetMessageType() Command_MessageType {
	if m != nil && m.MessageType != nil {
		return *m.MessageType
	}
	return Command_INVALID_MESSAGE_TYPE
}

func (m *Command_Header) GetTimeout() uint64 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *Command_Header) GetEarlyExit() bool {
	if m != nil && m.EarlyExit != nil {
		return *m.EarlyExit
	}
	return false
}

func (m *Command_Header) GetPriority() Command_Priority {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return Command_NORMAL
}

func (m *Command_Header) GetTimeQuanta() uint64 {
	if m != nil && m.TimeQuanta != nil {
		return *m.TimeQuanta
	}
	return 0
}

func (m *Command_Header) GetBatchID() uint32 {
	if m != nil && m.BatchID != nil {
		return *m.BatchID
	}
	return 0
}

//message body
type Command_Body struct {
	//key/value op
	KeyValue *Command_KeyValue `protobuf:"bytes,1,opt,name=keyValue" json:"keyValue,omitempty"`
	//range operation
	Range *Command_Range `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	//set up operation
	Setup *Command_Setup `protobuf:"bytes,3,opt,name=setup" json:"setup,omitempty"`
	// Peer to Peer operations.
	P2POperation *Command_P2POperation `protobuf:"bytes,4,opt,name=p2pOperation" json:"p2pOperation,omitempty"`
	//GetLog
	GetLog *Command_GetLog `protobuf:"bytes,6,opt,name=getLog" json:"getLog,omitempty"`
	//set up security
	Security *Command_Security `protobuf:"bytes,7,opt,name=security" json:"security,omitempty"`
	// Perform Pin-based operations
	PinOp *Command_PinOperation `protobuf:"bytes,8,opt,name=pinOp" json:"pinOp,omitempty"`
	// batch operation
	// This is included in the END_BATCH and END_BATCH_RESPONSE.
	Batch *Command_Batch `protobuf:"bytes,9,opt,name=batch" json:"batch,omitempty"`
	// power management
	Power                *Command_PowerManagement `protobuf:"bytes,10,opt,name=power" json:"power,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Command_Body) Reset()         { *m = Command_Body{} }
func (m *Command_Body) String() string { return proto.CompactTextString(m) }
func (*Command_Body) ProtoMessage()    {}
func (*Command_Body) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 1}
}

func (m *Command_Body) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Body.Unmarshal(m, b)
}
func (m *Command_Body) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Body.Marshal(b, m, deterministic)
}
func (m *Command_Body) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Body.Merge(m, src)
}
func (m *Command_Body) XXX_Size() int {
	return xxx_messageInfo_Command_Body.Size(m)
}
func (m *Command_Body) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Body.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Body proto.InternalMessageInfo

func (m *Command_Body) GetKeyValue() *Command_KeyValue {
	if m != nil {
		return m.KeyValue
	}
	return nil
}

func (m *Command_Body) GetRange() *Command_Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Command_Body) GetSetup() *Command_Setup {
	if m != nil {
		return m.Setup
	}
	return nil
}

func (m *Command_Body) GetP2POperation() *Command_P2POperation {
	if m != nil {
		return m.P2POperation
	}
	return nil
}

func (m *Command_Body) GetGetLog() *Command_GetLog {
	if m != nil {
		return m.GetLog
	}
	return nil
}

func (m *Command_Body) GetSecurity() *Command_Security {
	if m != nil {
		return m.Security
	}
	return nil
}

func (m *Command_Body) GetPinOp() *Command_PinOperation {
	if m != nil {
		return m.PinOp
	}
	return nil
}

func (m *Command_Body) GetBatch() *Command_Batch {
	if m != nil {
		return m.Batch
	}
	return nil
}

func (m *Command_Body) GetPower() *Command_PowerManagement {
	if m != nil {
		return m.Power
	}
	return nil
}

type Command_PowerManagement struct {
	Level                *Command_PowerLevel `protobuf:"varint,1,opt,name=level,enum=kinetic.Command_PowerLevel" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Command_PowerManagement) Reset()         { *m = Command_PowerManagement{} }
func (m *Command_PowerManagement) String() string { return proto.CompactTextString(m) }
func (*Command_PowerManagement) ProtoMessage()    {}
func (*Command_PowerManagement) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 2}
}

func (m *Command_PowerManagement) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_PowerManagement.Unmarshal(m, b)
}
func (m *Command_PowerManagement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_PowerManagement.Marshal(b, m, deterministic)
}
func (m *Command_PowerManagement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_PowerManagement.Merge(m, src)
}
func (m *Command_PowerManagement) XXX_Size() int {
	return xxx_messageInfo_Command_PowerManagement.Size(m)
}
func (m *Command_PowerManagement) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_PowerManagement.DiscardUnknown(m)
}

var xxx_messageInfo_Command_PowerManagement proto.InternalMessageInfo

func (m *Command_PowerManagement) GetLevel() Command_PowerLevel {
	if m != nil && m.Level != nil {
		return *m.Level
	}
	return Command_INVALID_LEVEL
}

// This is included in the END_BATCH and END_BATCH_RESPONSE.
type Command_Batch struct {
	// set by the client library in END_BATCH request message.
	// the total number of operations in the batch
	Count *uint32 `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	// set by the drive in END_BATCH_RESPONSE message.
	// If a batch is committed successfully, all sequence Ids of those
	// commands (PUT/DELETE) performed in the batch are
	// added in the END_BATCH_RESPONSE message.
	Sequence []uint64 `protobuf:"varint,2,rep,packed,name=sequence" json:"sequence,omitempty"`
	// This field is set by the drive if a batch commit failed.
	// The sequence of the first operation to fail in the batch.
	// There is no guarantee that the previous sequences would have succeeded.
	FailedSequence       *uint64  `protobuf:"varint,3,opt,name=failedSequence" json:"failedSequence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_Batch) Reset()         { *m = Command_Batch{} }
func (m *Command_Batch) String() string { return proto.CompactTextString(m) }
func (*Command_Batch) ProtoMessage()    {}
func (*Command_Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 3}
}

func (m *Command_Batch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Batch.Unmarshal(m, b)
}
func (m *Command_Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Batch.Marshal(b, m, deterministic)
}
func (m *Command_Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Batch.Merge(m, src)
}
func (m *Command_Batch) XXX_Size() int {
	return xxx_messageInfo_Command_Batch.Size(m)
}
func (m *Command_Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Batch proto.InternalMessageInfo

func (m *Command_Batch) GetCount() uint32 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *Command_Batch) GetSequence() []uint64 {
	if m != nil {
		return m.Sequence
	}
	return nil
}

func (m *Command_Batch) GetFailedSequence() uint64 {
	if m != nil && m.FailedSequence != nil {
		return *m.FailedSequence
	}
	return 0
}

//operation status
type Command_Status struct {
	//status code
	Code *Command_Status_StatusCode `protobuf:"varint,1,opt,name=code,enum=kinetic.Command_Status_StatusCode" json:"code,omitempty"`
	//status message
	StatusMessage *string `protobuf:"bytes,2,opt,name=statusMessage" json:"statusMessage,omitempty"`
	//optional information comes with status
	DetailedMessage      []byte   `protobuf:"bytes,3,opt,name=detailedMessage" json:"detailedMessage,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_Status) Reset()         { *m = Command_Status{} }
func (m *Command_Status) String() string { return proto.CompactTextString(m) }
func (*Command_Status) ProtoMessage()    {}
func (*Command_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 4}
}

func (m *Command_Status) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Status.Unmarshal(m, b)
}
func (m *Command_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Status.Marshal(b, m, deterministic)
}
func (m *Command_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Status.Merge(m, src)
}
func (m *Command_Status) XXX_Size() int {
	return xxx_messageInfo_Command_Status.Size(m)
}
func (m *Command_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Status proto.InternalMessageInfo

func (m *Command_Status) GetCode() Command_Status_StatusCode {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return Command_Status_INVALID_STATUS_CODE
}

func (m *Command_Status) GetStatusMessage() string {
	if m != nil && m.StatusMessage != nil {
		return *m.StatusMessage
	}
	return ""
}

func (m *Command_Status) GetDetailedMessage() []byte {
	if m != nil {
		return m.DetailedMessage
	}
	return nil
}

//key/value entry operation
type Command_KeyValue struct {
	// On a put, this is the next version that the data will be. The version field is opaque to the target.
	NewVersion []byte `protobuf:"bytes,2,opt,name=newVersion" json:"newVersion,omitempty"`
	// If set to True, puts will ignore any existing version (if it exists), and deletes will ignore
	// any existing version or if the key is not found (allowing a success on the delete of a non-existent key).
	Force *bool `protobuf:"varint,8,opt,name=force" json:"force,omitempty"`
	//entry key
	Key []byte `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	//entry version in store
	DbVersion []byte `protobuf:"bytes,4,opt,name=dbVersion" json:"dbVersion,omitempty"`
	// this is the integrity value of the data. This may or may not be in the clear, depending on the algorithm
	// used.
	Tag []byte `protobuf:"bytes,5,opt,name=tag" json:"tag,omitempty"`
	// The following is for the protection of the data. If the data is protected with a hash or CRC, then
	// the algorithm will be negative. If the data protection algorithm is not a standard unkeyed algorithm
	// then  a positive number is used and the device has no idea what the key is.
	Algorithm *Command_Algorithm `protobuf:"varint,6,opt,name=algorithm,enum=kinetic.Command_Algorithm" json:"algorithm,omitempty"`
	// for read operations, this will get all the information about the value except for the
	// value itself. This is valuable for getting the integrity field or the version without also
	// having to get the data.
	MetadataOnly *bool `protobuf:"varint,7,opt,name=metadataOnly" json:"metadataOnly,omitempty"`
	// Synchronization allows the puts and deletes to determine if they are to be
	// WRITETHROUGH: This request is made persistent before returning. This does not effect any other pending operations.
	// WRITEBACK: They can be made persistent when the device chooses, or when a subsequent FLUSH is give to the device.
	// FLUSH: All pending information that has not been written is pushed to the disk and the command that
	//    specifies FLUSH is written last and then returned. All WRITEBACK writes that have received ending
	//    status will be guaranteed to be written before the FLUSH operation is returned completed.
	Synchronization      *Command_Synchronization `protobuf:"varint,9,opt,name=synchronization,enum=kinetic.Command_Synchronization" json:"synchronization,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Command_KeyValue) Reset()         { *m = Command_KeyValue{} }
func (m *Command_KeyValue) String() string { return proto.CompactTextString(m) }
func (*Command_KeyValue) ProtoMessage()    {}
func (*Command_KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 5}
}

func (m *Command_KeyValue) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_KeyValue.Unmarshal(m, b)
}
func (m *Command_KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_KeyValue.Marshal(b, m, deterministic)
}
func (m *Command_KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_KeyValue.Merge(m, src)
}
func (m *Command_KeyValue) XXX_Size() int {
	return xxx_messageInfo_Command_KeyValue.Size(m)
}
func (m *Command_KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_Command_KeyValue proto.InternalMessageInfo

func (m *Command_KeyValue) GetNewVersion() []byte {
	if m != nil {
		return m.NewVersion
	}
	return nil
}

func (m *Command_KeyValue) GetForce() bool {
	if m != nil && m.Force != nil {
		return *m.Force
	}
	return false
}

func (m *Command_KeyValue) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Command_KeyValue) GetDbVersion() []byte {
	if m != nil {
		return m.DbVersion
	}
	return nil
}

func (m *Command_KeyValue) GetTag() []byte {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *Command_KeyValue) GetAlgorithm() Command_Algorithm {
	if m != nil && m.Algorithm != nil {
		return *m.Algorithm
	}
	return Command_INVALID_ALGORITHM
}

func (m *Command_KeyValue) GetMetadataOnly() bool {
	if m != nil && m.MetadataOnly != nil {
		return *m.MetadataOnly
	}
	return false
}

func (m *Command_KeyValue) GetSynchronization() Command_Synchronization {
	if m != nil && m.Synchronization != nil {
		return *m.Synchronization
	}
	return Command_INVALID_SYNCHRONIZATION
}

//key range op
type Command_Range struct {
	StartKey          []byte `protobuf:"bytes,1,opt,name=startKey" json:"startKey,omitempty"`
	EndKey            []byte `protobuf:"bytes,2,opt,name=endKey" json:"endKey,omitempty"`
	StartKeyInclusive *bool  `protobuf:"varint,3,opt,name=startKeyInclusive" json:"startKeyInclusive,omitempty"`
	EndKeyInclusive   *bool  `protobuf:"varint,4,opt,name=endKeyInclusive" json:"endKeyInclusive,omitempty"`
	// The maximum number of keys returned
	MaxReturned *uint32 `protobuf:"varint,5,opt,name=maxReturned" json:"maxReturned,omitempty"`
	// The keys are searched for and returned in a reverse order. For instance
	// if the search is startKey="j", endKey="k", maxReturned=2,
	// reverse=true and the keys "k0", "k1", "k2" exist
	// the system will return "k2" and "k1" in that order.
	Reverse *bool `protobuf:"varint,6,opt,name=reverse" json:"reverse,omitempty"`
	//get range response .
	Keys                 [][]byte `protobuf:"bytes,8,rep,name=keys" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_Range) Reset()         { *m = Command_Range{} }
func (m *Command_Range) String() string { return proto.CompactTextString(m) }
func (*Command_Range) ProtoMessage()    {}
func (*Command_Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 6}
}

func (m *Command_Range) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Range.Unmarshal(m, b)
}
func (m *Command_Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Range.Marshal(b, m, deterministic)
}
func (m *Command_Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Range.Merge(m, src)
}
func (m *Command_Range) XXX_Size() int {
	return xxx_messageInfo_Command_Range.Size(m)
}
func (m *Command_Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Range proto.InternalMessageInfo

func (m *Command_Range) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Command_Range) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Command_Range) GetStartKeyInclusive() bool {
	if m != nil && m.StartKeyInclusive != nil {
		return *m.StartKeyInclusive
	}
	return false
}

func (m *Command_Range) GetEndKeyInclusive() bool {
	if m != nil && m.EndKeyInclusive != nil {
		return *m.EndKeyInclusive
	}
	return false
}

func (m *Command_Range) GetMaxReturned() uint32 {
	if m != nil && m.MaxReturned != nil {
		return *m.MaxReturned
	}
	return 0
}

func (m *Command_Range) GetReverse() bool {
	if m != nil && m.Reverse != nil {
		return *m.Reverse
	}
	return false
}

func (m *Command_Range) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// These are persistent options that are retained across power fail and
// erased on either PIN erase or PIN secure erase.
type Command_Setup struct {
	// The cluster version to be checked. The default if never set is 0.
	// This is persistent between boots of the device.
	NewClusterVersion *int64 `protobuf:"varint,1,opt,name=newClusterVersion" json:"newClusterVersion,omitempty"`
	// Indicate the purpose of this message, tells the device what fields are relevent
	SetupOpType          *Command_Setup_SetupOpType `protobuf:"varint,6,opt,name=setupOpType,enum=kinetic.Command_Setup_SetupOpType" json:"setupOpType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Command_Setup) Reset()         { *m = Command_Setup{} }
func (m *Command_Setup) String() string { return proto.CompactTextString(m) }
func (*Command_Setup) ProtoMessage()    {}
func (*Command_Setup) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 7}
}

func (m *Command_Setup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Setup.Unmarshal(m, b)
}
func (m *Command_Setup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Setup.Marshal(b, m, deterministic)
}
func (m *Command_Setup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Setup.Merge(m, src)
}
func (m *Command_Setup) XXX_Size() int {
	return xxx_messageInfo_Command_Setup.Size(m)
}
func (m *Command_Setup) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Setup.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Setup proto.InternalMessageInfo

func (m *Command_Setup) GetNewClusterVersion() int64 {
	if m != nil && m.NewClusterVersion != nil {
		return *m.NewClusterVersion
	}
	return 0
}

func (m *Command_Setup) GetSetupOpType() Command_Setup_SetupOpType {
	if m != nil && m.SetupOpType != nil {
		return *m.SetupOpType
	}
	return Command_Setup_INVALID_SETUPOP
}

// P2P operations allow devices to be able to send keys to other devices.
// this is either a standalone command or added to a put command.
type Command_P2POperation struct {
	// Describe the target machine
	Peer *Command_P2POperation_Peer `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	// List of operations to be performed.
	Operation []*Command_P2POperation_Operation `protobuf:"bytes,2,rep,name=operation" json:"operation,omitempty"`
	// Indicates whether all operations have Status SUCCESS
	// When false, clients should traverse Operation status codes to discover
	// error cases.
	// When true, no further error checking should be required.
	AllChildOperationsSucceeded *bool    `protobuf:"varint,3,opt,name=allChildOperationsSucceeded" json:"allChildOperationsSucceeded,omitempty"`
	XXX_NoUnkeyedLiteral        struct{} `json:"-"`
	XXX_unrecognized            []byte   `json:"-"`
	XXX_sizecache               int32    `json:"-"`
}

func (m *Command_P2POperation) Reset()         { *m = Command_P2POperation{} }
func (m *Command_P2POperation) String() string { return proto.CompactTextString(m) }
func (*Command_P2POperation) ProtoMessage()    {}
func (*Command_P2POperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 8}
}

func (m *Command_P2POperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_P2POperation.Unmarshal(m, b)
}
func (m *Command_P2POperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_P2POperation.Marshal(b, m, deterministic)
}
func (m *Command_P2POperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_P2POperation.Merge(m, src)
}
func (m *Command_P2POperation) XXX_Size() int {
	return xxx_messageInfo_Command_P2POperation.Size(m)
}
func (m *Command_P2POperation) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_P2POperation.DiscardUnknown(m)
}

var xxx_messageInfo_Command_P2POperation proto.InternalMessageInfo

func (m *Command_P2POperation) GetPeer() *Command_P2POperation_Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Command_P2POperation) GetOperation() []*Command_P2POperation_Operation {
	if m != nil {
		return m.Operation
	}
	return nil
}

func (m *Command_P2POperation) GetAllChildOperationsSucceeded() bool {
	if m != nil && m.AllChildOperationsSucceeded != nil {
		return *m.AllChildOperationsSucceeded
	}
	return false
}

type Command_P2POperation_Operation struct {
	// the key of the entry to move
	Key []byte `protobuf:"bytes,3,opt,name=key" json:"key,omitempty"`
	// the expected version number in the other machine
	// the version number will be the version in the stored entry.
	Version []byte `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	// to have the moved key have a different final key used.
	NewKey []byte `protobuf:"bytes,5,opt,name=newKey" json:"newKey,omitempty"`
	// force the write ignoring the current key version.
	Force *bool `protobuf:"varint,6,opt,name=force" json:"force,omitempty"`
	// returned status
	Status *Command_Status `protobuf:"bytes,7,opt,name=status" json:"status,omitempty"`
	// an operation to add to this put operation. THis allows the
	// formation of a pipeline client -> A ->B ->C with the status for all returning
	// back to the client.
	P2Pop                *Command_P2POperation `protobuf:"bytes,8,opt,name=p2pop" json:"p2pop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Command_P2POperation_Operation) Reset()         { *m = Command_P2POperation_Operation{} }
func (m *Command_P2POperation_Operation) String() string { return proto.CompactTextString(m) }
func (*Command_P2POperation_Operation) ProtoMessage()    {}
func (*Command_P2POperation_Operation) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 8, 0}
}

func (m *Command_P2POperation_Operation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_P2POperation_Operation.Unmarshal(m, b)
}
func (m *Command_P2POperation_Operation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_P2POperation_Operation.Marshal(b, m, deterministic)
}
func (m *Command_P2POperation_Operation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_P2POperation_Operation.Merge(m, src)
}
func (m *Command_P2POperation_Operation) XXX_Size() int {
	return xxx_messageInfo_Command_P2POperation_Operation.Size(m)
}
func (m *Command_P2POperation_Operation) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_P2POperation_Operation.DiscardUnknown(m)
}

var xxx_messageInfo_Command_P2POperation_Operation proto.InternalMessageInfo

func (m *Command_P2POperation_Operation) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetVersion() []byte {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetNewKey() []byte {
	if m != nil {
		return m.NewKey
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetForce() bool {
	if m != nil && m.Force != nil {
		return *m.Force
	}
	return false
}

func (m *Command_P2POperation_Operation) GetStatus() *Command_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Command_P2POperation_Operation) GetP2Pop() *Command_P2POperation {
	if m != nil {
		return m.P2Pop
	}
	return nil
}

type Command_P2POperation_Peer struct {
	Hostname             *string  `protobuf:"bytes,1,opt,name=hostname" json:"hostname,omitempty"`
	Port                 *uint32  `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	Tls                  *bool    `protobuf:"varint,3,opt,name=tls" json:"tls,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_P2POperation_Peer) Reset()         { *m = Command_P2POperation_Peer{} }
func (m *Command_P2POperation_Peer) String() string { return proto.CompactTextString(m) }
func (*Command_P2POperation_Peer) ProtoMessage()    {}
func (*Command_P2POperation_Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 8, 1}
}

func (m *Command_P2POperation_Peer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_P2POperation_Peer.Unmarshal(m, b)
}
func (m *Command_P2POperation_Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_P2POperation_Peer.Marshal(b, m, deterministic)
}
func (m *Command_P2POperation_Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_P2POperation_Peer.Merge(m, src)
}
func (m *Command_P2POperation_Peer) XXX_Size() int {
	return xxx_messageInfo_Command_P2POperation_Peer.Size(m)
}
func (m *Command_P2POperation_Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_P2POperation_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Command_P2POperation_Peer proto.InternalMessageInfo

func (m *Command_P2POperation_Peer) GetHostname() string {
	if m != nil && m.Hostname != nil {
		return *m.Hostname
	}
	return ""
}

func (m *Command_P2POperation_Peer) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *Command_P2POperation_Peer) GetTls() bool {
	if m != nil && m.Tls != nil {
		return *m.Tls
	}
	return false
}

//get log
type Command_GetLog struct {
	Types                []Command_GetLog_Type         `protobuf:"varint,1,rep,name=types,enum=kinetic.Command_GetLog_Type" json:"types,omitempty"`
	Utilizations         []*Command_GetLog_Utilization `protobuf:"bytes,2,rep,name=utilizations" json:"utilizations,omitempty"`
	Temperatures         []*Command_GetLog_Temperature `protobuf:"bytes,3,rep,name=temperatures" json:"temperatures,omitempty"`
	Capacity             *Command_GetLog_Capacity      `protobuf:"bytes,4,opt,name=capacity" json:"capacity,omitempty"`
	Configuration        *Command_GetLog_Configuration `protobuf:"bytes,5,opt,name=configuration" json:"configuration,omitempty"`
	Statistics           []*Command_GetLog_Statistics  `protobuf:"bytes,6,rep,name=statistics" json:"statistics,omitempty"`
	Messages             []byte                        `protobuf:"bytes,7,opt,name=messages" json:"messages,omitempty"`
	Limits               *Command_GetLog_Limits        `protobuf:"bytes,8,opt,name=limits" json:"limits,omitempty"`
	Device               *Command_GetLog_Device        `protobuf:"bytes,9,opt,name=device" json:"device,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Command_GetLog) Reset()         { *m = Command_GetLog{} }
func (m *Command_GetLog) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog) ProtoMessage()    {}
func (*Command_GetLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9}
}

func (m *Command_GetLog) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog.Unmarshal(m, b)
}
func (m *Command_GetLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog.Marshal(b, m, deterministic)
}
func (m *Command_GetLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog.Merge(m, src)
}
func (m *Command_GetLog) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog.Size(m)
}
func (m *Command_GetLog) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog proto.InternalMessageInfo

func (m *Command_GetLog) GetTypes() []Command_GetLog_Type {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *Command_GetLog) GetUtilizations() []*Command_GetLog_Utilization {
	if m != nil {
		return m.Utilizations
	}
	return nil
}

func (m *Command_GetLog) GetTemperatures() []*Command_GetLog_Temperature {
	if m != nil {
		return m.Temperatures
	}
	return nil
}

func (m *Command_GetLog) GetCapacity() *Command_GetLog_Capacity {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *Command_GetLog) GetConfiguration() *Command_GetLog_Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

func (m *Command_GetLog) GetStatistics() []*Command_GetLog_Statistics {
	if m != nil {
		return m.Statistics
	}
	return nil
}

func (m *Command_GetLog) GetMessages() []byte {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *Command_GetLog) GetLimits() *Command_GetLog_Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *Command_GetLog) GetDevice() *Command_GetLog_Device {
	if m != nil {
		return m.Device
	}
	return nil
}

type Command_GetLog_Utilization struct {
	// The name of the utilization being reported. These names can be standard and proprietary. The
	// standard names are "HDA", "EN0" and "EN1". If there are more items that are
	// being reported, such as processor utilization, can have a descriptive name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// A number between 0.00 and 1.00. The resolution of this number is up to the
	// device. 1 means 100% utilized.
	Value                *float32 `protobuf:"fixed32,2,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_GetLog_Utilization) Reset()         { *m = Command_GetLog_Utilization{} }
func (m *Command_GetLog_Utilization) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Utilization) ProtoMessage()    {}
func (*Command_GetLog_Utilization) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 0}
}

func (m *Command_GetLog_Utilization) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Utilization.Unmarshal(m, b)
}
func (m *Command_GetLog_Utilization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Utilization.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Utilization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Utilization.Merge(m, src)
}
func (m *Command_GetLog_Utilization) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Utilization.Size(m)
}
func (m *Command_GetLog_Utilization) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Utilization.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Utilization proto.InternalMessageInfo

func (m *Command_GetLog_Utilization) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Command_GetLog_Utilization) GetValue() float32 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

type Command_GetLog_Temperature struct {
	// The name of the temperature being reported. These names can be standard and proprietary. The
	// standard name is "HDA". If there are more items that are
	// being reported, such as processor temperature, can have a descriptive name.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The current temperature in degrees c
	Current              *float32 `protobuf:"fixed32,2,opt,name=current" json:"current,omitempty"`
	Minimum              *float32 `protobuf:"fixed32,3,opt,name=minimum" json:"minimum,omitempty"`
	Maximum              *float32 `protobuf:"fixed32,4,opt,name=maximum" json:"maximum,omitempty"`
	Target               *float32 `protobuf:"fixed32,5,opt,name=target" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_GetLog_Temperature) Reset()         { *m = Command_GetLog_Temperature{} }
func (m *Command_GetLog_Temperature) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Temperature) ProtoMessage()    {}
func (*Command_GetLog_Temperature) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 1}
}

func (m *Command_GetLog_Temperature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Temperature.Unmarshal(m, b)
}
func (m *Command_GetLog_Temperature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Temperature.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Temperature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Temperature.Merge(m, src)
}
func (m *Command_GetLog_Temperature) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Temperature.Size(m)
}
func (m *Command_GetLog_Temperature) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Temperature.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Temperature proto.InternalMessageInfo

func (m *Command_GetLog_Temperature) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Command_GetLog_Temperature) GetCurrent() float32 {
	if m != nil && m.Current != nil {
		return *m.Current
	}
	return 0
}

func (m *Command_GetLog_Temperature) GetMinimum() float32 {
	if m != nil && m.Minimum != nil {
		return *m.Minimum
	}
	return 0
}

func (m *Command_GetLog_Temperature) GetMaximum() float32 {
	if m != nil && m.Maximum != nil {
		return *m.Maximum
	}
	return 0
}

func (m *Command_GetLog_Temperature) GetTarget() float32 {
	if m != nil && m.Target != nil {
		return *m.Target
	}
	return 0
}

// These capacities are in bytes.
type Command_GetLog_Capacity struct {
	// 1-3 are reserved
	NominalCapacityInBytes *uint64  `protobuf:"varint,4,opt,name=nominalCapacityInBytes" json:"nominalCapacityInBytes,omitempty"`
	PortionFull            *float32 `protobuf:"fixed32,5,opt,name=portionFull" json:"portionFull,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *Command_GetLog_Capacity) Reset()         { *m = Command_GetLog_Capacity{} }
func (m *Command_GetLog_Capacity) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Capacity) ProtoMessage()    {}
func (*Command_GetLog_Capacity) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 2}
}

func (m *Command_GetLog_Capacity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Capacity.Unmarshal(m, b)
}
func (m *Command_GetLog_Capacity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Capacity.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Capacity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Capacity.Merge(m, src)
}
func (m *Command_GetLog_Capacity) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Capacity.Size(m)
}
func (m *Command_GetLog_Capacity) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Capacity.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Capacity proto.InternalMessageInfo

func (m *Command_GetLog_Capacity) GetNominalCapacityInBytes() uint64 {
	if m != nil && m.NominalCapacityInBytes != nil {
		return *m.NominalCapacityInBytes
	}
	return 0
}

func (m *Command_GetLog_Capacity) GetPortionFull() float32 {
	if m != nil && m.PortionFull != nil {
		return *m.PortionFull
	}
	return 0
}

type Command_GetLog_Configuration struct {
	// name of the vendor.
	Vendor *string `protobuf:"bytes,5,opt,name=vendor" json:"vendor,omitempty"`
	// The model of the device.
	// "Simulator" for the simulator.
	Model *string `protobuf:"bytes,6,opt,name=model" json:"model,omitempty"`
	// Device Serial number (SN)
	SerialNumber []byte `protobuf:"bytes,7,opt,name=serialNumber" json:"serialNumber,omitempty"`
	// Device world wide name (WWN)
	WorldWideName []byte `protobuf:"bytes,14,opt,name=worldWideName" json:"worldWideName,omitempty"`
	// This is the vendor specific version of the software on the device in dot notation
	Version         *string `protobuf:"bytes,8,opt,name=version" json:"version,omitempty"`
	CompilationDate *string `protobuf:"bytes,12,opt,name=compilationDate" json:"compilationDate,omitempty"`
	SourceHash      *string `protobuf:"bytes,13,opt,name=sourceHash" json:"sourceHash,omitempty"`
	// This is the version of the protocol (.proto file) that the device uses.
	// This is not the highest or lowest version that is supported, just
	// the version that was compiled.
	ProtocolVersion         *string `protobuf:"bytes,15,opt,name=protocolVersion" json:"protocolVersion,omitempty"`
	ProtocolCompilationDate *string `protobuf:"bytes,16,opt,name=protocolCompilationDate" json:"protocolCompilationDate,omitempty"`
	ProtocolSourceHash      *string `protobuf:"bytes,17,opt,name=protocolSourceHash" json:"protocolSourceHash,omitempty"`
	// the interfaces for this device. one per interface.
	Interface []*Command_GetLog_Configuration_Interface `protobuf:"bytes,9,rep,name=interface" json:"interface,omitempty"`
	// these are the port numbers for the software
	Port    *uint32 `protobuf:"varint,10,opt,name=port" json:"port,omitempty"`
	TlsPort *uint32 `protobuf:"varint,11,opt,name=tlsPort" json:"tlsPort,omitempty"`
	// The unsolicited message at the beginning of a connection will return
	// the drive status. The only two possible values are OPERATIONAL
	// or HIBERNATE.
	CurrentPowerLevel    *Command_PowerLevel `protobuf:"varint,18,opt,name=currentPowerLevel,enum=kinetic.Command_PowerLevel" json:"currentPowerLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Command_GetLog_Configuration) Reset()         { *m = Command_GetLog_Configuration{} }
func (m *Command_GetLog_Configuration) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Configuration) ProtoMessage()    {}
func (*Command_GetLog_Configuration) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 3}
}

func (m *Command_GetLog_Configuration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Configuration.Unmarshal(m, b)
}
func (m *Command_GetLog_Configuration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Configuration.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Configuration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Configuration.Merge(m, src)
}
func (m *Command_GetLog_Configuration) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Configuration.Size(m)
}
func (m *Command_GetLog_Configuration) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Configuration.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Configuration proto.InternalMessageInfo

func (m *Command_GetLog_Configuration) GetVendor() string {
	if m != nil && m.Vendor != nil {
		return *m.Vendor
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetModel() string {
	if m != nil && m.Model != nil {
		return *m.Model
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetSerialNumber() []byte {
	if m != nil {
		return m.SerialNumber
	}
	return nil
}

func (m *Command_GetLog_Configuration) GetWorldWideName() []byte {
	if m != nil {
		return m.WorldWideName
	}
	return nil
}

func (m *Command_GetLog_Configuration) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetCompilationDate() string {
	if m != nil && m.CompilationDate != nil {
		return *m.CompilationDate
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetSourceHash() string {
	if m != nil && m.SourceHash != nil {
		return *m.SourceHash
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetProtocolVersion() string {
	if m != nil && m.ProtocolVersion != nil {
		return *m.ProtocolVersion
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetProtocolCompilationDate() string {
	if m != nil && m.ProtocolCompilationDate != nil {
		return *m.ProtocolCompilationDate
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetProtocolSourceHash() string {
	if m != nil && m.ProtocolSourceHash != nil {
		return *m.ProtocolSourceHash
	}
	return ""
}

func (m *Command_GetLog_Configuration) GetInterface() []*Command_GetLog_Configuration_Interface {
	if m != nil {
		return m.Interface
	}
	return nil
}

func (m *Command_GetLog_Configuration) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *Command_GetLog_Configuration) GetTlsPort() uint32 {
	if m != nil && m.TlsPort != nil {
		return *m.TlsPort
	}
	return 0
}

func (m *Command_GetLog_Configuration) GetCurrentPowerLevel() Command_PowerLevel {
	if m != nil && m.CurrentPowerLevel != nil {
		return *m.CurrentPowerLevel
	}
	return Command_INVALID_LEVEL
}

// 18, 19 are reserved.
type Command_GetLog_Configuration_Interface struct {
	Name                 *string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	MAC                  []byte   `protobuf:"bytes,2,opt,name=MAC" json:"MAC,omitempty"`
	Ipv4Address          []byte   `protobuf:"bytes,3,opt,name=ipv4Address" json:"ipv4Address,omitempty"`
	Ipv6Address          []byte   `protobuf:"bytes,4,opt,name=ipv6Address" json:"ipv6Address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_GetLog_Configuration_Interface) Reset() {
	*m = Command_GetLog_Configuration_Interface{}
}
func (m *Command_GetLog_Configuration_Interface) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Configuration_Interface) ProtoMessage()    {}
func (*Command_GetLog_Configuration_Interface) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 3, 0}
}

func (m *Command_GetLog_Configuration_Interface) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Configuration_Interface.Unmarshal(m, b)
}
func (m *Command_GetLog_Configuration_Interface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Configuration_Interface.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Configuration_Interface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Configuration_Interface.Merge(m, src)
}
func (m *Command_GetLog_Configuration_Interface) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Configuration_Interface.Size(m)
}
func (m *Command_GetLog_Configuration_Interface) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Configuration_Interface.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Configuration_Interface proto.InternalMessageInfo

func (m *Command_GetLog_Configuration_Interface) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Command_GetLog_Configuration_Interface) GetMAC() []byte {
	if m != nil {
		return m.MAC
	}
	return nil
}

func (m *Command_GetLog_Configuration_Interface) GetIpv4Address() []byte {
	if m != nil {
		return m.Ipv4Address
	}
	return nil
}

func (m *Command_GetLog_Configuration_Interface) GetIpv6Address() []byte {
	if m != nil {
		return m.Ipv6Address
	}
	return nil
}

// These numbers start at 0 when the device starts up and never wraps or resets.
type Command_GetLog_Statistics struct {
	MessageType *Command_MessageType `protobuf:"varint,1,opt,name=messageType,enum=kinetic.Command_MessageType" json:"messageType,omitempty"`
	// 2 and 3 are reserved, do not use
	Count *uint64 `protobuf:"varint,4,opt,name=count" json:"count,omitempty"`
	// This is the sum of the data that is in the data portion. This does not include t
	// the command description. For P2P operations, this is the amount of data moved between
	// devices
	Bytes                *uint64  `protobuf:"varint,5,opt,name=bytes" json:"bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_GetLog_Statistics) Reset()         { *m = Command_GetLog_Statistics{} }
func (m *Command_GetLog_Statistics) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Statistics) ProtoMessage()    {}
func (*Command_GetLog_Statistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 4}
}

func (m *Command_GetLog_Statistics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Statistics.Unmarshal(m, b)
}
func (m *Command_GetLog_Statistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Statistics.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Statistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Statistics.Merge(m, src)
}
func (m *Command_GetLog_Statistics) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Statistics.Size(m)
}
func (m *Command_GetLog_Statistics) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Statistics.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Statistics proto.InternalMessageInfo

func (m *Command_GetLog_Statistics) GetMessageType() Command_MessageType {
	if m != nil && m.MessageType != nil {
		return *m.MessageType
	}
	return Command_INVALID_MESSAGE_TYPE
}

func (m *Command_GetLog_Statistics) GetCount() uint64 {
	if m != nil && m.Count != nil {
		return *m.Count
	}
	return 0
}

func (m *Command_GetLog_Statistics) GetBytes() uint64 {
	if m != nil && m.Bytes != nil {
		return *m.Bytes
	}
	return 0
}

type Command_GetLog_Limits struct {
	MaxKeySize                  *uint32  `protobuf:"varint,1,opt,name=maxKeySize" json:"maxKeySize,omitempty"`
	MaxValueSize                *uint32  `protobuf:"varint,2,opt,name=maxValueSize" json:"maxValueSize,omitempty"`
	MaxVersionSize              *uint32  `protobuf:"varint,3,opt,name=maxVersionSize" json:"maxVersionSize,omitempty"`
	MaxTagSize                  *uint32  `protobuf:"varint,4,opt,name=maxTagSize" json:"maxTagSize,omitempty"`
	MaxConnections              *uint32  `protobuf:"varint,5,opt,name=maxConnections" json:"maxConnections,omitempty"`
	MaxOutstandingReadRequests  *uint32  `protobuf:"varint,6,opt,name=maxOutstandingReadRequests" json:"maxOutstandingReadRequests,omitempty"`
	MaxOutstandingWriteRequests *uint32  `protobuf:"varint,7,opt,name=maxOutstandingWriteRequests" json:"maxOutstandingWriteRequests,omitempty"`
	MaxMessageSize              *uint32  `protobuf:"varint,8,opt,name=maxMessageSize" json:"maxMessageSize,omitempty"`
	MaxKeyRangeCount            *uint32  `protobuf:"varint,9,opt,name=maxKeyRangeCount" json:"maxKeyRangeCount,omitempty"`
	MaxIdentityCount            *uint32  `protobuf:"varint,10,opt,name=maxIdentityCount" json:"maxIdentityCount,omitempty"`
	MaxPinSize                  *uint32  `protobuf:"varint,11,opt,name=maxPinSize" json:"maxPinSize,omitempty"`
	MaxOperationCountPerBatch   *uint32  `protobuf:"varint,12,opt,name=maxOperationCountPerBatch" json:"maxOperationCountPerBatch,omitempty"`
	MaxBatchCountPerDevice      *uint32  `protobuf:"varint,13,opt,name=maxBatchCountPerDevice" json:"maxBatchCountPerDevice,omitempty"`
	MaxBatchSize                *uint32  `protobuf:"varint,14,opt,name=maxBatchSize" json:"maxBatchSize,omitempty"`
	MaxDeletesPerBatch          *uint32  `protobuf:"varint,15,opt,name=maxDeletesPerBatch" json:"maxDeletesPerBatch,omitempty"`
	XXX_NoUnkeyedLiteral        struct{} `json:"-"`
	XXX_unrecognized            []byte   `json:"-"`
	XXX_sizecache               int32    `json:"-"`
}

func (m *Command_GetLog_Limits) Reset()         { *m = Command_GetLog_Limits{} }
func (m *Command_GetLog_Limits) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Limits) ProtoMessage()    {}
func (*Command_GetLog_Limits) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 5}
}

func (m *Command_GetLog_Limits) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Limits.Unmarshal(m, b)
}
func (m *Command_GetLog_Limits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Limits.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Limits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Limits.Merge(m, src)
}
func (m *Command_GetLog_Limits) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Limits.Size(m)
}
func (m *Command_GetLog_Limits) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Limits.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Limits proto.InternalMessageInfo

func (m *Command_GetLog_Limits) GetMaxKeySize() uint32 {
	if m != nil && m.MaxKeySize != nil {
		return *m.MaxKeySize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxValueSize() uint32 {
	if m != nil && m.MaxValueSize != nil {
		return *m.MaxValueSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxVersionSize() uint32 {
	if m != nil && m.MaxVersionSize != nil {
		return *m.MaxVersionSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxTagSize() uint32 {
	if m != nil && m.MaxTagSize != nil {
		return *m.MaxTagSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxConnections() uint32 {
	if m != nil && m.MaxConnections != nil {
		return *m.MaxConnections
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxOutstandingReadRequests() uint32 {
	if m != nil && m.MaxOutstandingReadRequests != nil {
		return *m.MaxOutstandingReadRequests
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxOutstandingWriteRequests() uint32 {
	if m != nil && m.MaxOutstandingWriteRequests != nil {
		return *m.MaxOutstandingWriteRequests
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxMessageSize() uint32 {
	if m != nil && m.MaxMessageSize != nil {
		return *m.MaxMessageSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxKeyRangeCount() uint32 {
	if m != nil && m.MaxKeyRangeCount != nil {
		return *m.MaxKeyRangeCount
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxIdentityCount() uint32 {
	if m != nil && m.MaxIdentityCount != nil {
		return *m.MaxIdentityCount
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxPinSize() uint32 {
	if m != nil && m.MaxPinSize != nil {
		return *m.MaxPinSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxOperationCountPerBatch() uint32 {
	if m != nil && m.MaxOperationCountPerBatch != nil {
		return *m.MaxOperationCountPerBatch
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxBatchCountPerDevice() uint32 {
	if m != nil && m.MaxBatchCountPerDevice != nil {
		return *m.MaxBatchCountPerDevice
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxBatchSize() uint32 {
	if m != nil && m.MaxBatchSize != nil {
		return *m.MaxBatchSize
	}
	return 0
}

func (m *Command_GetLog_Limits) GetMaxDeletesPerBatch() uint32 {
	if m != nil && m.MaxDeletesPerBatch != nil {
		return *m.MaxDeletesPerBatch
	}
	return 0
}

// The Device GetLog message is to ask the device to send back the
// log of a certain name in the value field. The limit of each
// log is 1m byte.
//
// Proprietary names should be prefaced by the vendor name so that name
// collisions do not happen in the future. An example could be names that
// start with com.WD would be for Western Digital devices.
//
// If the name is not found, the get log returns NOT_FOUND.
//
// There can be only one Device in the list of logs that can be retrieved.!
type Command_GetLog_Device struct {
	Name                 []byte   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command_GetLog_Device) Reset()         { *m = Command_GetLog_Device{} }
func (m *Command_GetLog_Device) String() string { return proto.CompactTextString(m) }
func (*Command_GetLog_Device) ProtoMessage()    {}
func (*Command_GetLog_Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 9, 6}
}

func (m *Command_GetLog_Device) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_GetLog_Device.Unmarshal(m, b)
}
func (m *Command_GetLog_Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_GetLog_Device.Marshal(b, m, deterministic)
}
func (m *Command_GetLog_Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_GetLog_Device.Merge(m, src)
}
func (m *Command_GetLog_Device) XXX_Size() int {
	return xxx_messageInfo_Command_GetLog_Device.Size(m)
}
func (m *Command_GetLog_Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_GetLog_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Command_GetLog_Device proto.InternalMessageInfo

func (m *Command_GetLog_Device) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

// These are persistent options that are retained across power fail and
// erased on either PIN erase or PIN secure erase.
type Command_Security struct {
	Acl []*Command_Security_ACL `protobuf:"bytes,2,rep,name=acl" json:"acl,omitempty"`
	// Set the lock and erase pins.
	OldLockPIN           []byte                           `protobuf:"bytes,3,opt,name=oldLockPIN" json:"oldLockPIN,omitempty"`
	NewLockPIN           []byte                           `protobuf:"bytes,4,opt,name=newLockPIN" json:"newLockPIN,omitempty"`
	OldErasePIN          []byte                           `protobuf:"bytes,5,opt,name=oldErasePIN" json:"oldErasePIN,omitempty"`
	NewErasePIN          []byte                           `protobuf:"bytes,6,opt,name=newErasePIN" json:"newErasePIN,omitempty"`
	SecurityOpType       *Command_Security_SecurityOpType `protobuf:"varint,7,opt,name=securityOpType,enum=kinetic.Command_Security_SecurityOpType" json:"securityOpType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *Command_Security) Reset()         { *m = Command_Security{} }
func (m *Command_Security) String() string { return proto.CompactTextString(m) }
func (*Command_Security) ProtoMessage()    {}
func (*Command_Security) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 10}
}

func (m *Command_Security) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Security.Unmarshal(m, b)
}
func (m *Command_Security) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Security.Marshal(b, m, deterministic)
}
func (m *Command_Security) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Security.Merge(m, src)
}
func (m *Command_Security) XXX_Size() int {
	return xxx_messageInfo_Command_Security.Size(m)
}
func (m *Command_Security) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Security.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Security proto.InternalMessageInfo

func (m *Command_Security) GetAcl() []*Command_Security_ACL {
	if m != nil {
		return m.Acl
	}
	return nil
}

func (m *Command_Security) GetOldLockPIN() []byte {
	if m != nil {
		return m.OldLockPIN
	}
	return nil
}

func (m *Command_Security) GetNewLockPIN() []byte {
	if m != nil {
		return m.NewLockPIN
	}
	return nil
}

func (m *Command_Security) GetOldErasePIN() []byte {
	if m != nil {
		return m.OldErasePIN
	}
	return nil
}

func (m *Command_Security) GetNewErasePIN() []byte {
	if m != nil {
		return m.NewErasePIN
	}
	return nil
}

func (m *Command_Security) GetSecurityOpType() Command_Security_SecurityOpType {
	if m != nil && m.SecurityOpType != nil {
		return *m.SecurityOpType
	}
	return Command_Security_INVALID_SECURITYOP
}

type Command_Security_ACL struct {
	Identity      *int64                              `protobuf:"varint,1,opt,name=identity" json:"identity,omitempty"`
	Key           []byte                              `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	HmacAlgorithm *Command_Security_ACL_HMACAlgorithm `protobuf:"varint,3,opt,name=hmacAlgorithm,enum=kinetic.Command_Security_ACL_HMACAlgorithm" json:"hmacAlgorithm,omitempty"`
	// value that must be in the key for read, write, range requests. If none are specified
	// then no checking occurs. If one or more is specified, one must match or the request
	// is rejected
	Scope []*Command_Security_ACL_Scope `protobuf:"bytes,4,rep,name=scope" json:"scope,omitempty"`
	// The maxPriority is checked against the header priority field. The header priority
	// for any command must be less than or equal to this maxPriority field.
	MaxPriority          *Command_Priority `protobuf:"varint,5,opt,name=maxPriority,enum=kinetic.Command_Priority" json:"maxPriority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Command_Security_ACL) Reset()         { *m = Command_Security_ACL{} }
func (m *Command_Security_ACL) String() string { return proto.CompactTextString(m) }
func (*Command_Security_ACL) ProtoMessage()    {}
func (*Command_Security_ACL) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 10, 0}
}

func (m *Command_Security_ACL) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Security_ACL.Unmarshal(m, b)
}
func (m *Command_Security_ACL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Security_ACL.Marshal(b, m, deterministic)
}
func (m *Command_Security_ACL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Security_ACL.Merge(m, src)
}
func (m *Command_Security_ACL) XXX_Size() int {
	return xxx_messageInfo_Command_Security_ACL.Size(m)
}
func (m *Command_Security_ACL) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Security_ACL.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Security_ACL proto.InternalMessageInfo

func (m *Command_Security_ACL) GetIdentity() int64 {
	if m != nil && m.Identity != nil {
		return *m.Identity
	}
	return 0
}

func (m *Command_Security_ACL) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Command_Security_ACL) GetHmacAlgorithm() Command_Security_ACL_HMACAlgorithm {
	if m != nil && m.HmacAlgorithm != nil {
		return *m.HmacAlgorithm
	}
	return Command_Security_ACL_INVALID_HMAC_ALGORITHM
}

func (m *Command_Security_ACL) GetScope() []*Command_Security_ACL_Scope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *Command_Security_ACL) GetMaxPriority() Command_Priority {
	if m != nil && m.MaxPriority != nil {
		return *m.MaxPriority
	}
	return Command_NORMAL
}

type Command_Security_ACL_Scope struct {
	Offset               *uint64                           `protobuf:"varint,1,opt,name=offset" json:"offset,omitempty"`
	Value                []byte                            `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Permission           []Command_Security_ACL_Permission `protobuf:"varint,3,rep,name=permission,enum=kinetic.Command_Security_ACL_Permission" json:"permission,omitempty"`
	TlsRequired          *bool                             `protobuf:"varint,4,opt,name=TlsRequired" json:"TlsRequired,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *Command_Security_ACL_Scope) Reset()         { *m = Command_Security_ACL_Scope{} }
func (m *Command_Security_ACL_Scope) String() string { return proto.CompactTextString(m) }
func (*Command_Security_ACL_Scope) ProtoMessage()    {}
func (*Command_Security_ACL_Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 10, 0, 0}
}

func (m *Command_Security_ACL_Scope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_Security_ACL_Scope.Unmarshal(m, b)
}
func (m *Command_Security_ACL_Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_Security_ACL_Scope.Marshal(b, m, deterministic)
}
func (m *Command_Security_ACL_Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_Security_ACL_Scope.Merge(m, src)
}
func (m *Command_Security_ACL_Scope) XXX_Size() int {
	return xxx_messageInfo_Command_Security_ACL_Scope.Size(m)
}
func (m *Command_Security_ACL_Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_Security_ACL_Scope.DiscardUnknown(m)
}

var xxx_messageInfo_Command_Security_ACL_Scope proto.InternalMessageInfo

func (m *Command_Security_ACL_Scope) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *Command_Security_ACL_Scope) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Command_Security_ACL_Scope) GetPermission() []Command_Security_ACL_Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *Command_Security_ACL_Scope) GetTlsRequired() bool {
	if m != nil && m.TlsRequired != nil {
		return *m.TlsRequired
	}
	return false
}

// Pin Operations are used for special commands that are valid when the device
// is locked or to be locked. These are unlock, lock and erase.
// This must come over the TLS connection to protect the confidentiality and
// integrity. This operations must be used with PinAuth.
type Command_PinOperation struct {
	PinOpType            *Command_PinOperation_PinOpType `protobuf:"varint,1,opt,name=pinOpType,enum=kinetic.Command_PinOperation_PinOpType" json:"pinOpType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *Command_PinOperation) Reset()         { *m = Command_PinOperation{} }
func (m *Command_PinOperation) String() string { return proto.CompactTextString(m) }
func (*Command_PinOperation) ProtoMessage()    {}
func (*Command_PinOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_b076ba9ab34784fc, []int{2, 11}
}

func (m *Command_PinOperation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command_PinOperation.Unmarshal(m, b)
}
func (m *Command_PinOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command_PinOperation.Marshal(b, m, deterministic)
}
func (m *Command_PinOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command_PinOperation.Merge(m, src)
}
func (m *Command_PinOperation) XXX_Size() int {
	return xxx_messageInfo_Command_PinOperation.Size(m)
}
func (m *Command_PinOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_Command_PinOperation.DiscardUnknown(m)
}

var xxx_messageInfo_Command_PinOperation proto.InternalMessageInfo

func (m *Command_PinOperation) GetPinOpType() Command_PinOperation_PinOpType {
	if m != nil && m.PinOpType != nil {
		return *m.PinOpType
	}
	return Command_PinOperation_INVALID_PINOP
}

func init() {
	proto.RegisterEnum("kinetic.Message_AuthType", Message_AuthType_name, Message_AuthType_value)
	proto.RegisterEnum("kinetic.Command_Synchronization", Command_Synchronization_name, Command_Synchronization_value)
	proto.RegisterEnum("kinetic.Command_Priority", Command_Priority_name, Command_Priority_value)
	proto.RegisterEnum("kinetic.Command_Algorithm", Command_Algorithm_name, Command_Algorithm_value)
	proto.RegisterEnum("kinetic.Command_MessageType", Command_MessageType_name, Command_MessageType_value)
	proto.RegisterEnum("kinetic.Command_PowerLevel", Command_PowerLevel_name, Command_PowerLevel_value)
	proto.RegisterEnum("kinetic.Command_Status_StatusCode", Command_Status_StatusCode_name, Command_Status_StatusCode_value)
	proto.RegisterEnum("kinetic.Command_Setup_SetupOpType", Command_Setup_SetupOpType_name, Command_Setup_SetupOpType_value)
	proto.RegisterEnum("kinetic.Command_GetLog_Type", Command_GetLog_Type_name, Command_GetLog_Type_value)
	proto.RegisterEnum("kinetic.Command_Security_SecurityOpType", Command_Security_SecurityOpType_name, Command_Security_SecurityOpType_value)
	proto.RegisterEnum("kinetic.Command_Security_ACL_HMACAlgorithm", Command_Security_ACL_HMACAlgorithm_name, Command_Security_ACL_HMACAlgorithm_value)
	proto.RegisterEnum("kinetic.Command_Security_ACL_Permission", Command_Security_ACL_Permission_name, Command_Security_ACL_Permission_value)
	proto.RegisterEnum("kinetic.Command_PinOperation_PinOpType", Command_PinOperation_PinOpType_name, Command_PinOperation_PinOpType_value)
	proto.RegisterType((*Local)(nil), "kinetic.Local")
	proto.RegisterType((*Message)(nil), "kinetic.Message")
	proto.RegisterType((*Message_HMACauth)(nil), "kinetic.Message.HMACauth")
	proto.RegisterType((*Message_PINauth)(nil), "kinetic.Message.PINauth")
	proto.RegisterType((*Command)(nil), "kinetic.Command")
	proto.RegisterType((*Command_Header)(nil), "kinetic.Command.Header")
	proto.RegisterType((*Command_Body)(nil), "kinetic.Command.Body")
	proto.RegisterType((*Command_PowerManagement)(nil), "kinetic.Command.PowerManagement")
	proto.RegisterType((*Command_Batch)(nil), "kinetic.Command.Batch")
	proto.RegisterType((*Command_Status)(nil), "kinetic.Command.Status")
	proto.RegisterType((*Command_KeyValue)(nil), "kinetic.Command.KeyValue")
	proto.RegisterType((*Command_Range)(nil), "kinetic.Command.Range")
	proto.RegisterType((*Command_Setup)(nil), "kinetic.Command.Setup")
	proto.RegisterType((*Command_P2POperation)(nil), "kinetic.Command.P2POperation")
	proto.RegisterType((*Command_P2POperation_Operation)(nil), "kinetic.Command.P2POperation.Operation")
	proto.RegisterType((*Command_P2POperation_Peer)(nil), "kinetic.Command.P2POperation.Peer")
	proto.RegisterType((*Command_GetLog)(nil), "kinetic.Command.GetLog")
	proto.RegisterType((*Command_GetLog_Utilization)(nil), "kinetic.Command.GetLog.Utilization")
	proto.RegisterType((*Command_GetLog_Temperature)(nil), "kinetic.Command.GetLog.Temperature")
	proto.RegisterType((*Command_GetLog_Capacity)(nil), "kinetic.Command.GetLog.Capacity")
	proto.RegisterType((*Command_GetLog_Configuration)(nil), "kinetic.Command.GetLog.Configuration")
	proto.RegisterType((*Command_GetLog_Configuration_Interface)(nil), "kinetic.Command.GetLog.Configuration.Interface")
	proto.RegisterType((*Command_GetLog_Statistics)(nil), "kinetic.Command.GetLog.Statistics")
	proto.RegisterType((*Command_GetLog_Limits)(nil), "kinetic.Command.GetLog.Limits")
	proto.RegisterType((*Command_GetLog_Device)(nil), "kinetic.Command.GetLog.Device")
	proto.RegisterType((*Command_Security)(nil), "kinetic.Command.Security")
	proto.RegisterType((*Command_Security_ACL)(nil), "kinetic.Command.Security.ACL")
	proto.RegisterType((*Command_Security_ACL_Scope)(nil), "kinetic.Command.Security.ACL.Scope")
	proto.RegisterType((*Command_PinOperation)(nil), "kinetic.Command.PinOperation")
}

func init() { proto.RegisterFile("kinetic_client.proto", fileDescriptor_b076ba9ab34784fc) }

var fileDescriptor_b076ba9ab34784fc = []byte{
	// 3502 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x59, 0x4f, 0x97, 0x1b, 0x49,
	0x52, 0x1f, 0xfd, 0x97, 0x42, 0xfd, 0xa7, 0x9c, 0xb6, 0xdb, 0xb2, 0xc6, 0xe3, 0x6d, 0x34, 0xb3,
	0x33, 0xbd, 0xbb, 0x43, 0x7b, 0xb6, 0x67, 0x30, 0xc3, 0xb2, 0x6f, 0xa1, 0xba, 0x94, 0x6e, 0x15,
	0x2d, 0xa9, 0x34, 0x59, 0x25, 0x7b, 0x3d, 0x8f, 0x87, 0x28, 0x4b, 0xe9, 0xee, 0x7a, 0x96, 0xaa,
	0x44, 0x55, 0xc9, 0xee, 0xde, 0xc7, 0x19, 0xb8, 0x71, 0xe3, 0x08, 0x0f, 0x4e, 0x1c, 0xf6, 0x33,
	0x70, 0xe7, 0xf1, 0x11, 0x38, 0x70, 0xe0, 0xf1, 0xf8, 0x08, 0x1c, 0x38, 0xc0, 0x8b, 0xcc, 0xac,
	0x3f, 0x92, 0xba, 0x9b, 0xc5, 0x87, 0x76, 0x66, 0xc4, 0x2f, 0x22, 0xa3, 0x32, 0x23, 0x22, 0x23,
	0x52, 0xf0, 0xe0, 0x9d, 0xe7, 0xf3, 0xd8, 0x9b, 0x4e, 0xa6, 0x73, 0x8f, 0xfb, 0xf1, 0xf1, 0x32,
	0x0c, 0xe2, 0x80, 0xd4, 0x14, 0xb5, 0xf3, 0x2d, 0x54, 0xfa, 0xc1, 0xd4, 0x9d, 0x93, 0x67, 0xb0,
	0x2f, 0x58, 0xd3, 0x60, 0xfe, 0x92, 0x87, 0x91, 0x17, 0xf8, 0xad, 0xc2, 0x61, 0xe1, 0xa8, 0xf1,
	0xb3, 0xca, 0x37, 0xc7, 0x5f, 0x1d, 0x7f, 0xc5, 0x36, 0xb9, 0x9d, 0xbf, 0x28, 0x41, 0x6d, 0xc0,
	0xa3, 0xc8, 0xbd, 0xe0, 0xe4, 0x77, 0xa0, 0xee, 0xae, 0xe2, 0x4b, 0xe7, 0x7a, 0xc9, 0x5b, 0xe5,
	0xc3, 0xc2, 0xd1, 0xde, 0xc9, 0xe3, 0x63, 0xb5, 0xc2, 0xb1, 0xc2, 0x1c, 0xeb, 0x0a, 0xc0, 0x52,
	0x28, 0x8a, 0x5d, 0x2e, 0xdc, 0x29, 0x72, 0x5a, 0x95, 0xc3, 0xc2, 0x51, 0xf3, 0x06, 0xb1, 0xde,
	0x40, 0x37, 0x50, 0x80, 0xa5, 0x50, 0x72, 0x02, 0xb5, 0xa5, 0xe7, 0x0b, 0xa9, 0xaa, 0x90, 0x6a,
	0x6d, 0x49, 0x8d, 0xcc, 0xa1, 0x10, 0x4a, 0x80, 0xa4, 0x03, 0x3b, 0xd3, 0x60, 0xb1, 0x70, 0xfd,
	0xd9, 0xe9, 0x75, 0xcc, 0xa3, 0x56, 0xed, 0xb0, 0x70, 0xb4, 0xc3, 0xd6, 0x68, 0xed, 0x9f, 0x41,
	0x3d, 0x59, 0x8d, 0xb4, 0xa1, 0xee, 0xcd, 0xb8, 0x1f, 0x7b, 0xf1, 0xb5, 0xd8, 0x87, 0x12, 0x4b,
	0xe7, 0x84, 0x40, 0x19, 0x6d, 0x69, 0x15, 0x85, 0x0e, 0x31, 0x6e, 0x7f, 0x0c, 0x35, 0xb5, 0x26,
	0xd1, 0xa0, 0xb4, 0xf4, 0xe4, 0xee, 0xed, 0x30, 0x1c, 0x76, 0xfe, 0x18, 0xea, 0xc9, 0xd7, 0x93,
	0xa7, 0x70, 0xcf, 0x1c, 0xbe, 0xd4, 0xfb, 0x66, 0x77, 0xa2, 0x8f, 0x9d, 0xde, 0xc4, 0x79, 0x3d,
	0xa2, 0xda, 0xff, 0x24, 0xff, 0x0a, 0x64, 0x47, 0x1a, 0x81, 0x3c, 0xad, 0x40, 0x9a, 0x42, 0xad,
	0x98, 0x14, 0xc9, 0x43, 0xb8, 0x37, 0x1e, 0xda, 0x56, 0xdf, 0x34, 0x4c, 0x87, 0x76, 0x6d, 0x47,
	0x77, 0xc6, 0xb6, 0x56, 0xea, 0xfc, 0xc7, 0x1f, 0x40, 0xcd, 0x90, 0xdf, 0x41, 0x9e, 0x41, 0xf5,
	0x92, 0xbb, 0x33, 0x1e, 0x8a, 0xe5, 0x9b, 0x27, 0x8f, 0xd2, 0x9d, 0x51, 0x88, 0xe3, 0x9e, 0x60,
	0x33, 0x05, 0x23, 0x3f, 0x82, 0xf2, 0x9b, 0x60, 0x76, 0x2d, 0xbe, 0xa5, 0x79, 0xf2, 0x70, 0x0b,
	0x7e, 0x1a, 0xcc, 0xae, 0x99, 0x80, 0xa0, 0xee, 0x28, 0x76, 0xe3, 0x55, 0xd4, 0x2a, 0xdd, 0xa2,
	0xdb, 0x16, 0x6c, 0xa6, 0x60, 0xed, 0xff, 0x2e, 0x42, 0x55, 0x2e, 0x47, 0x3e, 0x87, 0xbd, 0xe9,
	0x7c, 0x15, 0xc5, 0x3c, 0xcc, 0x3b, 0x57, 0x89, 0x6d, 0x50, 0xe5, 0x31, 0xf9, 0x3e, 0x9f, 0xc6,
	0x5e, 0xe0, 0x9b, 0x5d, 0xb1, 0x52, 0x89, 0xad, 0xd1, 0xf0, 0x68, 0x22, 0xfe, 0x67, 0x2b, 0xee,
	0x4f, 0xa5, 0xb3, 0x95, 0x59, 0x3a, 0x27, 0x87, 0xd0, 0x74, 0xa7, 0xef, 0xec, 0x84, 0x5d, 0x15,
	0xec, 0x3c, 0x89, 0xfc, 0x02, 0x9a, 0x0b, 0xe9, 0x24, 0xc2, 0x5b, 0x6b, 0xc2, 0x5b, 0x9f, 0x6c,
	0x7d, 0xca, 0x20, 0xc3, 0xb0, 0xbc, 0x00, 0x69, 0x41, 0x2d, 0xf6, 0x16, 0x3c, 0x58, 0xc5, 0xad,
	0x86, 0xd0, 0x9e, 0x4c, 0xc9, 0x13, 0x68, 0x70, 0x37, 0x9c, 0x5f, 0xd3, 0x2b, 0x2f, 0x6e, 0xc1,
	0x61, 0xe1, 0xa8, 0xce, 0x32, 0x02, 0xfa, 0xfa, 0x32, 0xf4, 0x82, 0x10, 0x1d, 0x6a, 0x67, 0x23,
	0x44, 0x92, 0x45, 0x47, 0x0a, 0xc0, 0x52, 0x28, 0x79, 0x0a, 0xe0, 0x78, 0x0b, 0xfe, 0xdd, 0xca,
	0xf5, 0x63, 0xb7, 0xb5, 0x2b, 0x56, 0xcc, 0x51, 0xd0, 0x9c, 0x37, 0x6e, 0x3c, 0xbd, 0x34, 0xbb,
	0xad, 0xbd, 0xc3, 0xc2, 0xd1, 0x2e, 0x4b, 0xa6, 0xed, 0x7f, 0x2b, 0x41, 0x19, 0x4f, 0x0f, 0x57,
	0x7e, 0xc7, 0xaf, 0x5f, 0xba, 0xf3, 0x15, 0x57, 0x5e, 0xb1, 0xbd, 0xf2, 0xb9, 0x02, 0xb0, 0x14,
	0x4a, 0xbe, 0x84, 0x4a, 0xe8, 0xfa, 0x17, 0x5c, 0xb9, 0xc6, 0xc1, 0x96, 0x0c, 0x43, 0x2e, 0x93,
	0x20, 0x44, 0x47, 0x3c, 0x5e, 0x2d, 0x95, 0x6f, 0x6c, 0xa3, 0x6d, 0xe4, 0x32, 0x09, 0x22, 0x3a,
	0xec, 0x2c, 0x4f, 0x96, 0xd6, 0x92, 0x87, 0x2e, 0x1e, 0xaa, 0x38, 0xc6, 0xe6, 0xc9, 0x27, 0xdb,
	0x1b, 0x72, 0x32, 0x4a, 0x41, 0x6c, 0x4d, 0x04, 0xbd, 0xf1, 0x82, 0xc7, 0xfd, 0xe0, 0x42, 0xe5,
	0x80, 0x6d, 0x6f, 0x3c, 0x13, 0x6c, 0xa6, 0x60, 0xb8, 0x0d, 0x11, 0x9f, 0xae, 0xc4, 0x01, 0xd4,
	0x6e, 0xd9, 0x06, 0x5b, 0x01, 0x58, 0x0a, 0x25, 0x5f, 0x43, 0x65, 0xe9, 0xf9, 0xd6, 0xb2, 0x55,
	0xbf, 0xcd, 0x46, 0xe4, 0x26, 0x36, 0x4a, 0x2c, 0xee, 0x86, 0x38, 0x06, 0xe1, 0x22, 0x37, 0xed,
	0xc6, 0x29, 0x72, 0x99, 0x04, 0x91, 0xe7, 0x50, 0x59, 0x06, 0x1f, 0x78, 0x28, 0x9c, 0xa6, 0x79,
	0x72, 0xb8, 0xbd, 0x04, 0x72, 0x07, 0xae, 0xef, 0x5e, 0xf0, 0x05, 0xf7, 0x63, 0x26, 0xe1, 0xed,
	0x2e, 0xec, 0x6f, 0x70, 0xc8, 0x4f, 0xa1, 0x32, 0xe7, 0xef, 0xf9, 0x5c, 0x1c, 0xf4, 0xde, 0xc9,
	0xc7, 0x37, 0xab, 0xea, 0x23, 0x84, 0x49, 0x64, 0x9b, 0x43, 0x45, 0x58, 0x43, 0x1e, 0x40, 0x65,
	0x1a, 0xac, 0xfc, 0x58, 0xc8, 0xee, 0x32, 0x39, 0x21, 0x4f, 0x73, 0xd1, 0x56, 0x3c, 0x2c, 0x1d,
	0x95, 0x4f, 0x8b, 0x5a, 0x21, 0x17, 0x71, 0x9f, 0xc3, 0xde, 0x5b, 0xd7, 0x9b, 0xf3, 0x59, 0x1a,
	0x74, 0x25, 0xe1, 0xa4, 0x1b, 0xd4, 0xf6, 0x3f, 0x54, 0xa0, 0x2a, 0xf3, 0x03, 0x79, 0x0e, 0xe5,
	0x69, 0x30, 0xe3, 0xca, 0xc6, 0xce, 0x2d, 0x69, 0x44, 0xfd, 0x67, 0x04, 0x33, 0xce, 0x04, 0x9e,
	0x7c, 0x06, 0xbb, 0x32, 0xb3, 0xa8, 0xe0, 0x14, 0x9e, 0xd9, 0x60, 0xeb, 0x44, 0x72, 0x04, 0xfb,
	0x33, 0x1e, 0x8b, 0xc5, 0x13, 0x5c, 0x49, 0xa4, 0xe2, 0x4d, 0x72, 0xe7, 0xaf, 0xcb, 0x00, 0xd9,
	0x22, 0xe4, 0x10, 0xee, 0x27, 0x99, 0x59, 0xe6, 0xd6, 0x89, 0x61, 0x75, 0xd7, 0x72, 0xf3, 0x3d,
	0xd8, 0x1d, 0x5a, 0xce, 0x44, 0x77, 0x1c, 0x3a, 0x18, 0x39, 0xb4, 0xab, 0x7d, 0x84, 0x09, 0xda,
	0x1e, 0x1b, 0x06, 0xb5, 0x6d, 0xad, 0x40, 0x34, 0xd8, 0xc1, 0xdc, 0x3d, 0x79, 0xa1, 0x9b, 0xfd,
	0x31, 0xa3, 0x5a, 0x91, 0x10, 0xd8, 0x13, 0x12, 0x63, 0xa7, 0x67, 0x31, 0xf3, 0x7b, 0xda, 0xd5,
	0x4a, 0xe4, 0x3e, 0xec, 0xbf, 0xa4, 0xcc, 0x36, 0xad, 0x61, 0x0a, 0x2c, 0x23, 0xd0, 0x1c, 0x3a,
	0x94, 0x0d, 0xf5, 0xfe, 0x84, 0x32, 0x66, 0x31, 0xad, 0x82, 0xc0, 0x1e, 0xd5, 0xbb, 0x94, 0x4d,
	0x18, 0xfd, 0x6e, 0x6c, 0x32, 0xda, 0xd5, 0xaa, 0x64, 0x17, 0x1a, 0xa8, 0xf1, 0x85, 0x35, 0x1e,
	0x76, 0xb5, 0x1a, 0x79, 0x00, 0x5a, 0xa2, 0x6c, 0x60, 0xda, 0x03, 0xdd, 0x31, 0x7a, 0x5a, 0x1d,
	0x0d, 0xb1, 0x29, 0x7b, 0x69, 0x1a, 0x74, 0x72, 0x3a, 0xb6, 0x5f, 0x6b, 0x0d, 0xb4, 0x93, 0xfe,
	0x72, 0x24, 0x74, 0x00, 0xd9, 0x03, 0xe8, 0xea, 0x8e, 0xae, 0x16, 0x6a, 0xe2, 0x42, 0x23, 0xca,
	0x06, 0x93, 0x1c, 0x71, 0x87, 0x7c, 0x0c, 0x8f, 0x18, 0x1d, 0x58, 0x0e, 0x9d, 0x18, 0xd6, 0x70,
	0x48, 0x0d, 0x07, 0xd7, 0x90, 0xcc, 0x5d, 0xbc, 0xa5, 0x86, 0xd6, 0xc4, 0x1e, 0xe9, 0x06, 0xd5,
	0xf6, 0x48, 0x1b, 0x0e, 0x70, 0x36, 0x36, 0x7a, 0x13, 0xf1, 0xfd, 0x7a, 0xff, 0xcc, 0x62, 0xa6,
	0xd3, 0x1b, 0x68, 0xfb, 0xa8, 0x3b, 0xd9, 0x55, 0xfc, 0x0a, 0x6a, 0x3b, 0x9a, 0x86, 0xba, 0x87,
	0xd4, 0x76, 0x68, 0x77, 0x62, 0x8d, 0x28, 0xd3, 0x33, 0xd5, 0xb6, 0x76, 0x0f, 0x77, 0xb9, 0x4b,
	0x85, 0xed, 0x7d, 0xcb, 0x38, 0xa7, 0x5d, 0x8d, 0x20, 0x5e, 0x91, 0xf4, 0x3e, 0xa3, 0x7a, 0xf7,
	0xf5, 0x64, 0x3c, 0x54, 0xcc, 0xfb, 0xe4, 0x31, 0x3c, 0xcc, 0x59, 0xe8, 0x50, 0x36, 0x30, 0x87,
	0x3a, 0x9e, 0xce, 0x03, 0x54, 0x95, 0x2c, 0x7e, 0x2a, 0xb6, 0xe6, 0x21, 0xee, 0x5f, 0xcf, 0x3c,
	0xc5, 0x8d, 0x76, 0xa8, 0x76, 0x80, 0x1f, 0x62, 0xf7, 0xc6, 0x4e, 0xd7, 0x7a, 0x35, 0xd4, 0x1e,
	0xb5, 0x7f, 0x5d, 0x84, 0x7a, 0x92, 0x0a, 0x31, 0xf5, 0xfa, 0xfc, 0x43, 0x72, 0x5f, 0xc9, 0xcb,
	0x3e, 0x47, 0xc1, 0x78, 0x79, 0x1b, 0x84, 0x53, 0x2e, 0x32, 0x43, 0x9d, 0xc9, 0x09, 0xde, 0xfe,
	0xef, 0xf8, 0xb5, 0x72, 0x39, 0x1c, 0xe2, 0xbd, 0x30, 0x7b, 0x93, 0xa8, 0x29, 0x0b, 0x7a, 0x46,
	0x40, 0x7c, 0xec, 0x5e, 0x88, 0xf2, 0x67, 0x87, 0xe1, 0x90, 0x7c, 0x0b, 0x0d, 0x77, 0x7e, 0x81,
	0xe9, 0xff, 0x72, 0x21, 0x92, 0xdb, 0xde, 0x49, 0x7b, 0x2b, 0x46, 0xf4, 0x04, 0xc1, 0x32, 0x30,
	0xde, 0x9e, 0x0b, 0x1e, 0xbb, 0x33, 0x37, 0x76, 0x2d, 0x7f, 0x2e, 0xd3, 0x5c, 0x9d, 0xad, 0xd1,
	0xc8, 0x1f, 0xc1, 0x7e, 0x74, 0xed, 0x4f, 0x2f, 0xc3, 0xc0, 0xf7, 0x7e, 0x25, 0xb3, 0x6f, 0x43,
	0xac, 0xb1, 0x9d, 0x76, 0xec, 0x75, 0x1c, 0xdb, 0x14, 0x6c, 0xff, 0x7b, 0x01, 0x2a, 0xe2, 0x16,
	0x10, 0x77, 0x72, 0xec, 0x86, 0xf1, 0x39, 0xbf, 0x56, 0x85, 0x4f, 0x3a, 0x27, 0x07, 0x50, 0xe5,
	0xfe, 0x0c, 0x39, 0x72, 0x0f, 0xd5, 0x8c, 0x7c, 0x09, 0xf7, 0x12, 0x8c, 0xe9, 0x63, 0x1d, 0xe0,
	0xbd, 0x97, 0xa1, 0x5a, 0x67, 0xdb, 0x0c, 0x0c, 0x6b, 0x29, 0x97, 0x61, 0xcb, 0x02, 0xbb, 0x49,
	0xc6, 0x1a, 0x60, 0xe1, 0x5e, 0x31, 0x1e, 0xaf, 0x42, 0x9f, 0xcf, 0xc4, 0xce, 0xee, 0xb2, 0x3c,
	0x09, 0x2f, 0xcd, 0x90, 0xbf, 0xe7, 0x61, 0x24, 0x2b, 0x84, 0x3a, 0x4b, 0xa6, 0x58, 0xda, 0xbd,
	0xe3, 0xd7, 0x51, 0xab, 0x7e, 0x58, 0xc2, 0xd2, 0x0e, 0xc7, 0xed, 0x7f, 0x2d, 0x40, 0x45, 0xdc,
	0x5e, 0x68, 0xb1, 0xcf, 0x3f, 0x18, 0x37, 0x15, 0x32, 0xdb, 0x0c, 0xd2, 0x85, 0xa6, 0xb8, 0xed,
	0xac, 0xa5, 0xa8, 0x34, 0xaa, 0xb7, 0x65, 0x3b, 0xc4, 0xc8, 0xbf, 0x12, 0xc9, 0xf2, 0x62, 0x9d,
	0x3f, 0x81, 0x66, 0x8e, 0x47, 0x9e, 0x64, 0xe1, 0x64, 0x53, 0x67, 0x3c, 0xb2, 0x46, 0xf9, 0x04,
	0xf5, 0x00, 0xb4, 0x17, 0x26, 0x1b, 0xbc, 0xd2, 0x19, 0x4d, 0xd9, 0x05, 0x8c, 0x1e, 0xa3, 0x3f,
	0xb6, 0x1d, 0xca, 0x26, 0x49, 0xae, 0x48, 0x98, 0xc5, 0xf6, 0x7f, 0x96, 0x60, 0x27, 0x7f, 0xcd,
	0x62, 0x76, 0x5e, 0xf2, 0xb4, 0x80, 0xec, 0xdc, 0x79, 0x27, 0x1f, 0x8f, 0x38, 0x0f, 0x99, 0xc0,
	0x13, 0x0a, 0x8d, 0x20, 0xbd, 0xd0, 0xf1, 0xa6, 0x68, 0x9e, 0x7c, 0x71, 0xb7, 0x70, 0x76, 0x6d,
	0x66, 0x92, 0xe4, 0x0f, 0xe1, 0x63, 0x77, 0x3e, 0x37, 0x2e, 0xbd, 0xf9, 0x2c, 0xe5, 0x47, 0xf6,
	0x6a, 0x3a, 0xe5, 0x7c, 0xc6, 0x67, 0xca, 0x3f, 0xee, 0x82, 0xb4, 0xff, 0xa5, 0x00, 0x8d, 0xec,
	0x73, 0xb6, 0xe3, 0xb1, 0x05, 0xb5, 0xf7, 0x6b, 0xd1, 0x98, 0x4c, 0xd1, 0x53, 0x7d, 0xfe, 0x01,
	0x3d, 0x55, 0x86, 0xa3, 0x9a, 0x65, 0x91, 0x5e, 0xcd, 0x47, 0x7a, 0x56, 0x0f, 0xd7, 0x7e, 0xa3,
	0x7a, 0x58, 0x94, 0x12, 0x27, 0xcb, 0xe0, 0x8e, 0x52, 0x22, 0x5f, 0xee, 0x48, 0x6c, 0xbb, 0x07,
	0x65, 0xdc, 0x64, 0x8c, 0xb0, 0xcb, 0x20, 0x8a, 0x7d, 0x77, 0x21, 0x2f, 0xce, 0x06, 0x4b, 0xe7,
	0xe8, 0xb5, 0xcb, 0x20, 0x8c, 0x45, 0x7c, 0xed, 0x32, 0x31, 0x16, 0x79, 0x65, 0x1e, 0xa9, 0xfd,
	0xc2, 0x61, 0xfb, 0xbf, 0xee, 0x43, 0x55, 0xd6, 0x44, 0xe4, 0x04, 0x2a, 0xf1, 0xf5, 0x92, 0x47,
	0xad, 0xc2, 0x61, 0xe9, 0xc6, 0xf2, 0x57, 0xe2, 0x8e, 0x85, 0x3b, 0x4a, 0x28, 0x39, 0x83, 0x9d,
	0x55, 0xec, 0xcd, 0x55, 0xec, 0x47, 0xea, 0x88, 0x3f, 0xbd, 0x4d, 0x74, 0x9c, 0x61, 0xd9, 0x9a,
	0x20, 0x2a, 0x8a, 0xf9, 0x42, 0x7c, 0xe7, 0x2a, 0xe4, 0x68, 0xe2, 0x9d, 0x8a, 0x9c, 0x0c, 0xcb,
	0xd6, 0x04, 0xc9, 0xcf, 0xa1, 0x3e, 0x75, 0x97, 0xee, 0x14, 0x2b, 0xba, 0xf2, 0x2d, 0xa5, 0x93,
	0x52, 0x62, 0x28, 0x1c, 0x4b, 0x25, 0xc8, 0x39, 0xec, 0x4e, 0x03, 0xff, 0xad, 0x77, 0xb1, 0x52,
	0x3e, 0x2b, 0x3b, 0xd0, 0x1f, 0xde, 0xaa, 0x22, 0x0f, 0x66, 0xeb, 0xb2, 0xe4, 0x14, 0x00, 0x0f,
	0xd9, 0x8b, 0x62, 0x6f, 0x1a, 0xb5, 0xaa, 0xe2, 0x8b, 0x3a, 0xb7, 0x69, 0xb2, 0x53, 0x24, 0xcb,
	0x49, 0xe1, 0x09, 0xab, 0x46, 0x23, 0x69, 0x4f, 0xd3, 0x39, 0x79, 0x0e, 0xd5, 0xb9, 0xb7, 0xf0,
	0xe2, 0x48, 0xf9, 0xce, 0xd3, 0xdb, 0x74, 0xf7, 0x05, 0x8a, 0x29, 0x34, 0xca, 0xcd, 0xf8, 0x7b,
	0x6f, 0xca, 0x55, 0x25, 0x7a, 0xab, 0x5c, 0x57, 0xa0, 0x98, 0x42, 0xb7, 0x7f, 0x17, 0x9a, 0xb9,
	0x03, 0x44, 0x07, 0xcb, 0x39, 0x9e, 0x18, 0x63, 0x50, 0xbc, 0x17, 0x3d, 0x05, 0x7a, 0x5d, 0x91,
	0xc9, 0x49, 0xfb, 0x2f, 0x0b, 0xd0, 0xcc, 0x9d, 0xd8, 0x8d, 0x92, 0x2d, 0xa8, 0x4d, 0x57, 0x61,
	0xc8, 0xfd, 0x58, 0xc9, 0x26, 0x53, 0xe4, 0x2c, 0x3c, 0xdf, 0x5b, 0xac, 0x16, 0xc2, 0x71, 0x8b,
	0x2c, 0x99, 0x0a, 0x8e, 0x7b, 0x25, 0x38, 0x65, 0xc5, 0x91, 0x53, 0x0c, 0xda, 0xd8, 0x0d, 0x2f,
	0x78, 0x2c, 0x0e, 0xb0, 0xc8, 0xd4, 0xac, 0x3d, 0x83, 0x7a, 0x72, 0xea, 0xe4, 0x39, 0x1c, 0xf8,
	0xc1, 0xc2, 0xf3, 0xdd, 0x79, 0x42, 0x32, 0x7d, 0xf9, 0x0e, 0x20, 0x1b, 0xc8, 0x5b, 0xb8, 0x78,
	0x95, 0x60, 0x30, 0x79, 0x81, 0xff, 0x62, 0x35, 0x9f, 0xab, 0x05, 0xf2, 0xa4, 0xf6, 0x3f, 0x55,
	0x60, 0x77, 0xcd, 0x33, 0xd0, 0x9e, 0xf7, 0xdc, 0x9f, 0x05, 0xa1, 0x80, 0x37, 0x98, 0x9a, 0xe1,
	0x7e, 0x2d, 0x82, 0x19, 0x9f, 0x8b, 0x24, 0xd2, 0x60, 0x72, 0x82, 0x57, 0x76, 0xc4, 0x43, 0xcf,
	0x9d, 0x0f, 0x57, 0x8b, 0x37, 0x3c, 0x4c, 0xde, 0x25, 0xf2, 0x34, 0xac, 0x7b, 0x3f, 0x04, 0xe1,
	0x7c, 0xf6, 0xca, 0x9b, 0xf1, 0x21, 0x6e, 0xe6, 0x9e, 0x00, 0xad, 0x13, 0xf3, 0x69, 0xad, 0x2e,
	0x56, 0x48, 0xd3, 0xda, 0x11, 0xec, 0x4f, 0x83, 0xc5, 0xd2, 0x9b, 0x0b, 0x03, 0xbb, 0x6e, 0xcc,
	0x45, 0x07, 0xda, 0x60, 0x9b, 0x64, 0x2c, 0x79, 0xa2, 0x60, 0x15, 0x4e, 0x79, 0xcf, 0x8d, 0x2e,
	0x45, 0xb7, 0xd9, 0x60, 0x39, 0x0a, 0x6a, 0xda, 0x7c, 0x24, 0xda, 0x97, 0x9a, 0x36, 0xc8, 0xe4,
	0x5b, 0x78, 0x94, 0x90, 0x8c, 0x8d, 0xb5, 0x35, 0x21, 0x71, 0x1b, 0x9b, 0x1c, 0x03, 0x49, 0x58,
	0x76, 0x66, 0xcb, 0x3d, 0x21, 0x74, 0x03, 0x87, 0x0c, 0xa0, 0xe1, 0xf9, 0x31, 0x0f, 0xdf, 0xba,
	0xc2, 0xcb, 0x31, 0xf2, 0x9e, 0xfd, 0x46, 0x31, 0x7c, 0x6c, 0x26, 0x62, 0x2c, 0xd3, 0x90, 0xe6,
	0x52, 0xc8, 0xe5, 0x52, 0xec, 0xf9, 0xe7, 0xd1, 0x08, 0xc9, 0x4d, 0xd9, 0x64, 0xab, 0x29, 0x31,
	0xe1, 0x9e, 0xf2, 0xdd, 0xac, 0xb1, 0x6a, 0x91, 0xff, 0xbb, 0xf7, 0xda, 0x96, 0x6a, 0xaf, 0xa0,
	0x61, 0xe6, 0xad, 0xd8, 0x0a, 0x1b, 0x0d, 0x4a, 0x03, 0xdd, 0x50, 0x45, 0x14, 0x0e, 0xd1, 0x3d,
	0xbd, 0xe5, 0xfb, 0x6f, 0xf4, 0xd9, 0x2c, 0xe4, 0x51, 0xa4, 0xee, 0xb8, 0x3c, 0x49, 0x21, 0x9e,
	0x27, 0x88, 0x72, 0x8a, 0x48, 0x48, 0xed, 0x2b, 0xd9, 0x03, 0xa9, 0x1c, 0xb4, 0xf1, 0x3a, 0x52,
	0xf8, 0xff, 0xbe, 0x8e, 0xa4, 0x3d, 0xa4, 0x8c, 0x2b, 0xd5, 0x43, 0x3e, 0x80, 0xca, 0x1b, 0x11,
	0x6d, 0x15, 0x49, 0x15, 0x93, 0xf6, 0x3f, 0x56, 0xa0, 0x2a, 0xd3, 0x15, 0xfa, 0xdd, 0xc2, 0xbd,
	0x3a, 0xe7, 0xd7, 0xb6, 0xf7, 0x2b, 0xae, 0xfa, 0xcf, 0x1c, 0x45, 0x14, 0xb6, 0xee, 0x95, 0x28,
	0xcb, 0x05, 0x42, 0x5e, 0x74, 0x6b, 0x34, 0x6c, 0x44, 0x71, 0x2e, 0xfd, 0x4f, 0xa0, 0x4a, 0x02,
	0xb5, 0x41, 0x55, 0x6b, 0x39, 0xee, 0x85, 0xc0, 0x94, 0xd3, 0xb5, 0x14, 0x45, 0xe9, 0x31, 0xd2,
	0x17, 0xa7, 0x48, 0x55, 0x90, 0x1b, 0x54, 0xf2, 0x0b, 0x68, 0x2f, 0xdc, 0x2b, 0x6b, 0x15, 0x47,
	0xb1, 0xeb, 0xcf, 0x3c, 0xff, 0x82, 0x71, 0x77, 0xc6, 0xb0, 0xdd, 0x8d, 0xe2, 0x48, 0x04, 0xf9,
	0x2e, 0xbb, 0x03, 0x81, 0x85, 0xce, 0x3a, 0xf7, 0x55, 0xe8, 0xc5, 0x3c, 0x55, 0x50, 0x13, 0x0a,
	0xee, 0x82, 0x28, 0x4b, 0xd5, 0x59, 0x88, 0xaf, 0xa9, 0xa7, 0x96, 0xe6, 0xa8, 0xe4, 0xc7, 0xa0,
	0xc9, 0xbd, 0x14, 0xb5, 0xba, 0x21, 0xce, 0xa7, 0x21, 0x90, 0x5b, 0x74, 0x85, 0x35, 0xd5, 0x53,
	0xa7, 0xc4, 0x42, 0x8a, 0x5d, 0xa3, 0xab, 0x9d, 0x1c, 0x79, 0x72, 0xb7, 0x9b, 0xe9, 0x4e, 0x2a,
	0x0a, 0xf9, 0x39, 0x3c, 0x46, 0xf3, 0x93, 0x8a, 0x46, 0x08, 0x8d, 0x78, 0x28, 0x5e, 0x1b, 0x44,
	0x06, 0xda, 0x65, 0xb7, 0x03, 0x30, 0x67, 0x2f, 0xdc, 0x2b, 0x31, 0x4e, 0x18, 0xf2, 0x92, 0x12,
	0x79, 0x69, 0x97, 0xdd, 0xc2, 0x55, 0xbe, 0x22, 0x38, 0xc2, 0xae, 0xbd, 0xd4, 0x57, 0x52, 0x1a,
	0xe6, 0x98, 0x85, 0x7b, 0xd5, 0xe5, 0x73, 0x1e, 0xf3, 0x28, 0x35, 0x69, 0x5f, 0x20, 0x6f, 0xe0,
	0xb4, 0x9f, 0x40, 0x55, 0x69, 0xcf, 0x07, 0xe6, 0x8e, 0x0c, 0xcc, 0xce, 0xdf, 0x16, 0xa0, 0x2c,
	0xbc, 0xff, 0x31, 0xec, 0x24, 0xc5, 0xf9, 0xe6, 0xb3, 0xae, 0x06, 0x3b, 0x63, 0xc7, 0xec, 0x9b,
	0xdf, 0x8b, 0x66, 0xd7, 0xd6, 0x3e, 0x42, 0x8a, 0x43, 0x07, 0xa2, 0xfd, 0x1d, 0x33, 0x6a, 0x6b,
	0x05, 0x6c, 0xcb, 0x0d, 0x7d, 0xa4, 0x1b, 0xa6, 0x63, 0x52, 0x5b, 0x2b, 0x62, 0xf7, 0x6a, 0x58,
	0xc3, 0x17, 0xe6, 0xd9, 0x58, 0xb6, 0xc8, 0x5a, 0x09, 0x21, 0xb6, 0xa3, 0x3b, 0xa6, 0xed, 0x98,
	0x86, 0xad, 0x95, 0xb1, 0x7d, 0x1d, 0x50, 0xdb, 0xd6, 0xcf, 0xa8, 0xad, 0x55, 0x08, 0x40, 0xb5,
	0x6f, 0x0e, 0x4c, 0xc7, 0xd6, 0xaa, 0x38, 0x96, 0x2d, 0xb3, 0x56, 0x6b, 0xff, 0x4d, 0x1d, 0xea,
	0xc9, 0xd3, 0x16, 0x79, 0x06, 0x25, 0x77, 0x3a, 0x57, 0xe5, 0xdb, 0x27, 0xb7, 0x3e, 0x81, 0x1d,
	0xeb, 0x46, 0x9f, 0x21, 0x12, 0x8f, 0x39, 0x98, 0xcf, 0xfa, 0xc1, 0xf4, 0xdd, 0xc8, 0x1c, 0xaa,
	0x24, 0x93, 0xa3, 0xa8, 0x3e, 0x39, 0xe1, 0x97, 0xd3, 0x3e, 0x39, 0xe1, 0x1f, 0x42, 0x33, 0x98,
	0xcf, 0x68, 0xe8, 0x46, 0x1c, 0x01, 0xb2, 0xb4, 0xce, 0x93, 0x10, 0xe1, 0xf3, 0x0f, 0x29, 0xa2,
	0x2a, 0x11, 0x39, 0x12, 0x19, 0xc1, 0x5e, 0xf2, 0x22, 0xa7, 0xda, 0x29, 0xf9, 0x70, 0x7b, 0x74,
	0xbb, 0xfd, 0xf6, 0x1a, 0x9e, 0x6d, 0xc8, 0xb7, 0xff, 0xaa, 0x02, 0x25, 0xdd, 0xe8, 0xdf, 0xf9,
	0xd0, 0xaf, 0x7a, 0x87, 0x62, 0xd6, 0x3b, 0x7c, 0x07, 0xbb, 0xe2, 0x67, 0x88, 0xb4, 0x3f, 0x2f,
	0x09, 0x33, 0x7e, 0x72, 0xe7, 0x36, 0x8a, 0xdf, 0x30, 0xb2, 0x86, 0x7d, 0x5d, 0x03, 0xf9, 0x3d,
	0xa8, 0x44, 0xd3, 0x40, 0xfc, 0x70, 0x72, 0x73, 0x1d, 0xbc, 0xa6, 0xca, 0x46, 0x28, 0x93, 0x12,
	0xe4, 0xf7, 0x45, 0xa7, 0x9b, 0xbc, 0x1a, 0x8b, 0x9d, 0xbd, 0xf3, 0x59, 0x39, 0x8f, 0x6e, 0xff,
	0x3d, 0xb6, 0xb5, 0x42, 0xcd, 0x01, 0x54, 0x83, 0xb7, 0x6f, 0x23, 0x2e, 0x5f, 0xfe, 0xca, 0x4c,
	0xcd, 0xd6, 0x2b, 0xbc, 0x1d, 0x55, 0xe1, 0x91, 0x1e, 0xc0, 0x92, 0x87, 0x0b, 0x2f, 0x12, 0xd7,
	0x7f, 0x49, 0x34, 0x10, 0x47, 0x77, 0x1b, 0x3d, 0x4a, 0xf1, 0x2c, 0x27, 0x8b, 0xc7, 0xee, 0xcc,
	0x23, 0x4c, 0x67, 0x5e, 0xc8, 0x67, 0xaa, 0x9d, 0xcf, 0x93, 0x3a, 0xa7, 0xb0, 0xbb, 0xb6, 0x77,
	0xe4, 0x53, 0x38, 0x48, 0x22, 0x6c, 0xe3, 0xa5, 0x69, 0xe3, 0x27, 0x94, 0x85, 0x3b, 0xb5, 0x7b,
	0xfa, 0x4f, 0xb5, 0x42, 0xe7, 0xef, 0x0a, 0x00, 0x99, 0x01, 0xe4, 0x07, 0x40, 0x12, 0x0d, 0x23,
	0xca, 0x06, 0xa6, 0x8d, 0xfd, 0x70, 0x5e, 0xba, 0x0e, 0x65, 0x46, 0xf5, 0xae, 0xf6, 0x11, 0x69,
	0x40, 0xe5, 0x15, 0x33, 0x1d, 0xaa, 0x15, 0x64, 0x34, 0xf5, 0xa9, 0x43, 0xb5, 0x22, 0x92, 0x99,
	0x3e, 0x3c, 0xa3, 0x5a, 0x09, 0x87, 0xa2, 0x93, 0xd6, 0xca, 0x38, 0xc4, 0xf6, 0x6d, 0x24, 0xc3,
	0xf0, 0x8c, 0x3a, 0x7d, 0xeb, 0x4c, 0xab, 0x89, 0xf7, 0x25, 0x6a, 0x8c, 0x99, 0xe9, 0xbc, 0xd6,
	0xea, 0xd8, 0x9f, 0x8f, 0xac, 0x57, 0x94, 0x4d, 0x06, 0xfa, 0x50, 0x3f, 0xa3, 0x03, 0x3a, 0x74,
	0xb4, 0x46, 0xe7, 0x0a, 0xf6, 0xd6, 0x9d, 0x35, 0x6f, 0x64, 0x22, 0xbd, 0xde, 0xe8, 0x13, 0xd8,
	0xd3, 0x8d, 0x7e, 0x9e, 0x59, 0x20, 0x2d, 0x78, 0x40, 0x99, 0x6e, 0xd3, 0xc9, 0xc8, 0x1c, 0xe6,
	0x39, 0x45, 0xf2, 0x08, 0xee, 0xf7, 0x2d, 0xe3, 0x7c, 0x93, 0x51, 0x6a, 0xff, 0x73, 0x01, 0x76,
	0xf2, 0xef, 0xd7, 0xd8, 0xc4, 0x8b, 0x17, 0xec, 0xdc, 0xed, 0xff, 0xc5, 0x9d, 0x2f, 0xde, 0x72,
	0x22, 0x22, 0x2c, 0x93, 0xec, 0x84, 0xd0, 0x48, 0xe9, 0xa4, 0x9d, 0x3d, 0xc2, 0x8d, 0xcc, 0xe1,
	0xfa, 0x77, 0x60, 0x5a, 0x1c, 0x26, 0xb6, 0x89, 0xaf, 0xd8, 0x03, 0xc8, 0xcd, 0x8b, 0x64, 0x1f,
	0x9a, 0xe9, 0x57, 0xa1, 0xcd, 0xe4, 0x00, 0x88, 0xf8, 0x06, 0x3a, 0xc9, 0xd3, 0xcb, 0x9d, 0x29,
	0xec, 0x6f, 0x3c, 0x58, 0x91, 0xcf, 0xe0, 0x51, 0xba, 0x8d, 0xaf, 0x87, 0x46, 0x8f, 0x59, 0x43,
	0x95, 0x80, 0x37, 0x6c, 0x10, 0xc7, 0xec, 0xf4, 0x98, 0x35, 0x3e, 0xeb, 0x69, 0x05, 0xb2, 0x0b,
	0x0d, 0x41, 0x39, 0xd5, 0x8d, 0x73, 0x79, 0xe0, 0x2f, 0xfa, 0x63, 0xbb, 0xa7, 0x95, 0x3a, 0x7f,
	0x0e, 0xf5, 0x24, 0x80, 0xf0, 0x98, 0x87, 0x16, 0x1b, 0xe8, 0x7d, 0x95, 0x79, 0xad, 0x57, 0xd4,
	0x76, 0xb4, 0x02, 0xc2, 0x71, 0xcc, 0xb4, 0x22, 0xa9, 0x41, 0xa9, 0x6f, 0xbd, 0xd2, 0x4a, 0xf8,
	0x15, 0x82, 0xa6, 0x04, 0xca, 0xe2, 0xa9, 0xd8, 0x3c, 0xeb, 0xa5, 0x94, 0x2a, 0xfa, 0x1d, 0x52,
	0xb4, 0x1a, 0x2a, 0x93, 0x3c, 0xad, 0x4e, 0x9a, 0x50, 0x13, 0x63, 0x1b, 0x1d, 0xe5, 0x1d, 0x34,
	0xb2, 0x50, 0xc8, 0xff, 0x90, 0x78, 0x53, 0x14, 0xd4, 0xa1, 0x2c, 0x23, 0x40, 0x8d, 0x4e, 0xb4,
	0xa2, 0x1a, 0x7d, 0xad, 0x95, 0x70, 0x0d, 0x83, 0x19, 0x5f, 0x9f, 0x18, 0xd2, 0x75, 0x0d, 0x66,
	0x3c, 0xff, 0x46, 0xab, 0xa8, 0xe1, 0xd7, 0x27, 0x5a, 0xb5, 0xf3, 0xeb, 0x2a, 0x34, 0x73, 0x75,
	0x1e, 0xf9, 0x2d, 0x78, 0x90, 0xac, 0xa7, 0xae, 0x9c, 0xad, 0x4b, 0xae, 0x06, 0xa5, 0x33, 0xea,
	0x68, 0x45, 0xfc, 0xba, 0x33, 0xea, 0x4c, 0x18, 0xb5, 0x47, 0xd6, 0xd0, 0xc6, 0x00, 0xaa, 0x41,
	0x69, 0x34, 0x76, 0xe4, 0x87, 0x8f, 0xc6, 0x39, 0x56, 0x29, 0x17, 0x5b, 0x55, 0x72, 0x1f, 0xf6,
	0xe5, 0x38, 0x03, 0x54, 0x70, 0x0f, 0xce, 0xa8, 0x33, 0xa4, 0xbf, 0x74, 0x64, 0x08, 0xa9, 0x49,
	0x06, 0xa9, 0xe1, 0xfe, 0x9e, 0x51, 0x67, 0xc4, 0xe8, 0x4b, 0xd3, 0x1a, 0xdb, 0x1a, 0x60, 0x30,
	0xe4, 0x08, 0x19, 0xb4, 0xa1, 0xa0, 0xe7, 0xf4, 0xb5, 0x0c, 0xe2, 0x1d, 0x05, 0x4d, 0x08, 0x19,
	0xb4, 0x89, 0xbe, 0x78, 0x46, 0x1d, 0xf5, 0x66, 0xa6, 0x69, 0x18, 0x47, 0xd9, 0x3c, 0x03, 0xee,
	0x67, 0x79, 0xe0, 0x00, 0x23, 0x53, 0x0c, 0x33, 0xf6, 0xc3, 0x5c, 0x42, 0x68, 0xe1, 0x17, 0xca,
	0x71, 0x06, 0x78, 0xb4, 0x96, 0x25, 0xda, 0xe4, 0x21, 0xdc, 0x4b, 0x66, 0x19, 0xe8, 0x31, 0x96,
	0x03, 0x23, 0x4a, 0xd9, 0x09, 0xfe, 0x19, 0xa1, 0x3b, 0x3e, 0x21, 0x6d, 0x38, 0x58, 0x23, 0x65,
	0xf0, 0x8f, 0xf1, 0xac, 0x87, 0x96, 0x35, 0xd2, 0x9e, 0xca, 0x9f, 0x2d, 0xac, 0x9c, 0x45, 0x9f,
	0xe0, 0x29, 0x08, 0x97, 0xd6, 0xfb, 0xfd, 0xae, 0xee, 0xe8, 0xda, 0x21, 0x79, 0x0c, 0x0f, 0xf3,
	0x94, 0x0c, 0xfc, 0x03, 0x91, 0xda, 0x44, 0x90, 0x7d, 0x86, 0x5f, 0x27, 0x86, 0x19, 0xfb, 0x53,
	0x8c, 0x96, 0x01, 0xed, 0x9a, 0xba, 0x6d, 0xe8, 0x43, 0xed, 0x73, 0x8c, 0xcf, 0x74, 0x9a, 0xc1,
	0x7e, 0x88, 0x56, 0x08, 0xba, 0x35, 0x72, 0xcc, 0x81, 0xf9, 0x3d, 0xd5, 0x8e, 0xd0, 0xfc, 0x35,
	0x52, 0x06, 0xff, 0x02, 0x8f, 0xc9, 0x76, 0x74, 0xe6, 0xa8, 0x87, 0xfb, 0x1f, 0xe3, 0x31, 0xe5,
	0x08, 0x19, 0xf4, 0x47, 0x68, 0x00, 0x1d, 0x26, 0x2f, 0xfc, 0x5f, 0xa2, 0x01, 0xe9, 0x34, 0x83,
	0xfd, 0x04, 0x35, 0xea, 0xa7, 0x56, 0xaa, 0xf1, 0x18, 0x35, 0xe6, 0x08, 0x19, 0xf4, 0xb7, 0xf1,
	0x90, 0x6c, 0xea, 0x4c, 0x64, 0xae, 0xee, 0xd3, 0x97, 0xb4, 0xaf, 0x7d, 0x45, 0x9e, 0x40, 0x6b,
	0x83, 0x98, 0x89, 0x3c, 0xeb, 0xfc, 0x29, 0x40, 0xd6, 0xcc, 0xe5, 0x73, 0x9e, 0x14, 0xcf, 0x45,
	0xc9, 0x3e, 0x34, 0xd3, 0x5f, 0x3d, 0xf4, 0xbe, 0x4c, 0x37, 0xd9, 0x4f, 0x12, 0xc5, 0xb5, 0x9f,
	0x24, 0x4a, 0x78, 0x8c, 0x2f, 0x74, 0xb3, 0xaf, 0x95, 0x4f, 0x1b, 0xa7, 0xb5, 0x73, 0x99, 0x89,
	0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0xd9, 0x7c, 0x25, 0x11, 0xd5, 0x21, 0x00, 0x00,
}
